<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="扩展的UTxO模型" /><meta name="author" content="Cardano" /><meta property="og:locale" content="en" /><meta name="description" content="序言" /><meta property="og:description" content="序言" /><link rel="canonical" href="/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/" /><meta property="og:url" content="/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/" /><meta property="og:site_name" content="Lovelace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-29T09:12:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="扩展的UTxO模型" /><meta name="google-site-verification" content="hYrEuDXdYFrLw9klfbDC2ltqWoXRXTNHWmgf9bgO838" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Cardano"},"headline":"扩展的UTxO模型","dateModified":"2022-03-29T09:12:00+08:00","datePublished":"2022-03-29T09:12:00+08:00","description":"序言","url":"/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/"},"@context":"https://schema.org"}</script><title>扩展的UTxO模型 | Lovelace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Lovelace"><meta name="application-name" content="Lovelace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?d0140067dd798ddd08fa1dfeecc191bb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Lovelace</a></div><div class="site-subtitle font-italic">所有的善恶都是我，良心一路走来依旧清澈鲜活...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/haskell-monad" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['haskell.lisp','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>扩展的UTxO模型</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>扩展的UTxO模型</h1><div class="post-meta text-muted"><div> By <em> <a href="https://www.notion.so/Extended-UTXO-7cc52460f0bd4a0f8a7a3097330f830b">Cardano</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-03-29T09:12:00+08:00" data-toggle="tooltip" data-placement="bottom" title="Tue, Mar 29, 2022, 9:12 AM +0800" >Mar 29, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6603 words"> <em>36 min</em> read</span></div></div></div><div class="post-content"><h3 id="序言">序言 <a href="#序言" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>区块链是状态机 —— 它们跟踪状态(例如，每个钱包持有多少比特币)和状态随时间的变化。</p><p>每笔交易(因此每一个区块)都会改变区块链的状态。在区块链中跟踪和管理状态的两种最流行的方法是: 未使用的交易输出(<code class="language-plaintext highlighter-rouge">UTxO</code>)模型和<code class="language-plaintext highlighter-rouge">Account</code>(账户)模型。</p><p><code class="language-plaintext highlighter-rouge">UTxO</code>模型是由比特币开创的，可以直观地认为是类似现金的(下面将进一步详述)，而账户模型是由以太坊推广的，可以直观地认为是类似银行账户的。与所有工程和设计决策一样，<code class="language-plaintext highlighter-rouge">UTxO</code>和账户模型需要权衡取舍。 例如，账户模型比<code class="language-plaintext highlighter-rouge">UTxO</code>模型具有更多的表达能力，但具有更差的确定性(当底层区块链使用账户模型时，交易更有可能失败)。</p><p>支持<code class="language-plaintext highlighter-rouge">Cardano</code>项目的科学和研究机构<code class="language-plaintext highlighter-rouge">IOHK</code>的团队已经创新了一种新的状态管理系统，他们称之为<a href="https://iohk.io/en/research/library/papers/the-extended-utxo-model/">扩展的UTxO模型</a>(<code class="language-plaintext highlighter-rouge">eUTxO</code>)。<code class="language-plaintext highlighter-rouge">eUTxO</code>模型是<code class="language-plaintext highlighter-rouge">UTxO</code>模型和账户模型的综合，它结合了账户模型的表达能力和<code class="language-plaintext highlighter-rouge">UTxO</code>模型的隐私性、安全性、并发性和确定性。</p><p>有<a href="https://academy.horizen.io/technology/expert/utxo-vs-account-model">很多</a> <a href="https://ergoplatform.org/en/blog/2020_03_03_building_utxo/">文章</a> <a href="https://dappworks.com/utxo-based-smart-contract-vs-account-based-smart-contract/">比较</a> <a href="https://medium.com/nervosnetwork/my-comparison-between-the-utxo-and-account-model-821eb46691b2">比特币的</a><a href="https://bitcoin.stackexchange.com/questions/49853/utxo-model-vs-account-balance-model">UTxO</a> <a href="https://academy.glassnode.com/concepts/utxo">模型</a> <a href="https://ethereum.stackexchange.com/questions/326/what-are-the-pros-and-cons-of-ethereum-balances-vs-utxos">和</a> <a href="https://blockonomi.com/utxo-vs-account-based-transaction-models/">以太坊的</a><a href="https://hackernoon.com/utxo-and-account-model-comparison-v-2-cdf9669c6c0d">帐户</a><a href="https://blog.hashex.org/utxo-and-account-model-comparison-c4098a9bc119">模型</a> 但很少有文章将这种比较扩展到<code class="language-plaintext highlighter-rouge">eUTxO</code>模型。本文将快速介绍<code class="language-plaintext highlighter-rouge">UTxO</code>和<code class="language-plaintext highlighter-rouge">Account</code>模型的基础知识，并尝试彻底解释<code class="language-plaintext highlighter-rouge">eUTxO</code>模型。</p><h3 id="utxo模型">UTxO模型 <a href="#utxo模型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>首先，让我们为比特币开创的<code class="language-plaintext highlighter-rouge">UTxO</code>模型建立一些直觉。请记住，<code class="language-plaintext highlighter-rouge">UTxO</code>代表未使用/未花费的交易输出。让我们从一个基于上述直觉的例子开始，即<code class="language-plaintext highlighter-rouge">UTxO</code>模型类似于现金。</p><p>假设<code class="language-plaintext highlighter-rouge">Alice</code>有一张100美元的钞票，她需要付给<code class="language-plaintext highlighter-rouge">Bob</code> 3美元。 <code class="language-plaintext highlighter-rouge">Alice</code>将她的100美元钞票交给<code class="language-plaintext highlighter-rouge">Bob</code>，然后<code class="language-plaintext highlighter-rouge">Bob</code>将返还给<code class="language-plaintext highlighter-rouge">Alice</code>97美元。</p><p>在此示例中，<code class="language-plaintext highlighter-rouge">Alice</code>以价值100美元的未花费交易输出(<code class="language-plaintext highlighter-rouge">UTxO</code>)开始。然后，她在一笔交易中(花费/消费)了该输出(100美元的钞票)，从而产生了2个新的未花费交易输出(<code class="language-plaintext highlighter-rouge">UTxOs</code>)，一个为3美元(由<code class="language-plaintext highlighter-rouge">Bob</code>拥有)，另一个为97美元(由<code class="language-plaintext highlighter-rouge">Alice</code>拥有)。现在请注意，原来的100美元的<code class="language-plaintext highlighter-rouge">UTxO</code>不能再次(消费/花费)。</p><p>每个<code class="language-plaintext highlighter-rouge">UTxO</code>只能使用一次，并且可以生成一个或多个新的<code class="language-plaintext highlighter-rouge">UTxOs</code>。 <code class="language-plaintext highlighter-rouge">UTxO</code>模型中的每笔交易都会接收一个<code class="language-plaintext highlighter-rouge">UTxOs</code>输入列表，消费它们，并创建一个新的<code class="language-plaintext highlighter-rouge">UTxOs</code>列表，这些新的<code class="language-plaintext highlighter-rouge">UTxOs</code>可以稍后在新的交易中(使用/花费)。 <code class="language-plaintext highlighter-rouge">UTxO</code>的另一个值得注意的特性是，交易的输入值必须始终等于输出值(减去区块链为处理交易而收取的任何费用)。</p><p><img data-src="/assets/img/cardano/utxo/utxo.png" alt="" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">UTxO</code>模型具有很好的并发性，因为状态是本地的(与下面描述的<code class="language-plaintext highlighter-rouge">Account</code>模型的全局状态相比)。这种本地状态的概念源自这样一个事实: <code class="language-plaintext highlighter-rouge">UTxO</code>特定于每个钱包。如果<code class="language-plaintext highlighter-rouge">Alice</code>与<code class="language-plaintext highlighter-rouge">Charlie</code>进行交易，这不可能影响<code class="language-plaintext highlighter-rouge">Bob</code>的交易能力，因为<code class="language-plaintext highlighter-rouge">Alice</code>无法消费<code class="language-plaintext highlighter-rouge">Bob</code>的<code class="language-plaintext highlighter-rouge">UTxOs</code>。账户模型中并非如此，我们将在下一节中详细说明。因为<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>进行的交易之间没有任何依赖关系，所以他们的交易可以更有效地并行化。</p><p>有人认为<code class="language-plaintext highlighter-rouge">UTxO</code>模型具有更好的隐私属性，但我还不相信。据称，<code class="language-plaintext highlighter-rouge">UTxO</code>模型具有更好的隐私性，因为用户可以为每笔交易使用新钱包，并在收到他们发起的交易的零钱时(即: <code class="language-plaintext highlighter-rouge">Alice</code>在上面的示例中获得了97美元的零钱)。虽然<code class="language-plaintext highlighter-rouge">Account</code>模型没有<code class="language-plaintext highlighter-rouge">change</code>(找零)的概念，但用户也可以选择为<code class="language-plaintext highlighter-rouge">Account</code>模型中的每笔交易创建一个新钱包。在为每笔交易创建新钱包时，<code class="language-plaintext highlighter-rouge">UTxO</code>模型的一个好处是，分布在多个钱包中的价值可以比在账户模型中更容易地(整合/合并)。<code class="language-plaintext highlighter-rouge">UTxO</code>模型中的整合理论上可以在单个交易中完成，因为可以一次消耗所有<code class="language-plaintext highlighter-rouge">UTxO</code>并创建单个输出(但是块大小的实际限制将限制这一点，例如，一次最多消耗6个<code class="language-plaintext highlighter-rouge">UTxO</code>)。</p><p><code class="language-plaintext highlighter-rouge">UTxO</code>模型的一个缺点是交易的大小。在<code class="language-plaintext highlighter-rouge">UTxO</code>模型中，每笔交易都指定一个输入列表和一个输出列表。这意味着一些有很多输入和输出的交易可能会变得非常大。</p><p>帐户模型中的交易较小，这将在下文更详细地描述。另一个很大的缺点是模型的概念困难 - 大多数人比<code class="language-plaintext highlighter-rouge">UTxO</code>模型更容易理解和概念化帐户模型，这意味着用户和开发人员都有更大的错误空间。 <code class="language-plaintext highlighter-rouge">UTxO</code>模型的最后一个问题是它的<a href="https://en.bitcoinwiki.org/wiki/Script">智能合约能力有限</a>。比特币对<a href="https://thebitcoinmanual.com/articles/what-is-a-bitcoin-smart-contract/">多重签名、时间锁定交易和P2SH</a>等智能合约的支持有限。但是，比特币<code class="language-plaintext highlighter-rouge">UTxO</code>模型不支持<a href="https://stackoverflow.com/questions/7284/what-is-turing-complete">图灵完备</a>的脚本。</p><h3 id="account模型">Account模型 <a href="#account模型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>与<code class="language-plaintext highlighter-rouge">UTxO</code>模型相比，账户模型可以直观地被认为类似于银行账户。账户模型中的交易指定<code class="language-plaintext highlighter-rouge">debits</code>(借方)和<code class="language-plaintext highlighter-rouge">credits</code>(贷方)，而不是消费和创建<code class="language-plaintext highlighter-rouge">UTxO</code>。让我们再次假设<code class="language-plaintext highlighter-rouge">Alice</code>有100美元并想向<code class="language-plaintext highlighter-rouge">Bob</code>发送3美元，尽管这次钱不是现金形式，而是存在银行账户中。为了让<code class="language-plaintext highlighter-rouge">Alice</code>将这笔钱汇给<code class="language-plaintext highlighter-rouge">Bob</code>，她要求她的银行从她的账户中<code class="language-plaintext highlighter-rouge">debit</code>(借记)3美元，并在<code class="language-plaintext highlighter-rouge">Bob</code>的账户中<code class="language-plaintext highlighter-rouge">credit</code>(贷记)3美元。请注意这里没有<code class="language-plaintext highlighter-rouge">change</code>(找零)的概念，以及银行如何管理这些<code class="language-plaintext highlighter-rouge">credits</code>(贷方)和<code class="language-plaintext highlighter-rouge">debits</code>(借方)。</p><p>我们在上面提到了<code class="language-plaintext highlighter-rouge">UTxO</code>模型对于大多数用户来说是如何不那么直观的，希望这个例子能说明为什么会这样。从概念上来说，用”未花费的交易输出”来思考是很困难的，但从贷方和借方的角度来看却很容易。我们还提到了当有很多的输入和输出时，<code class="language-plaintext highlighter-rouge">UTxO</code>模型中的交易如何变得非常大。账户模型中的交易更简单、更小，因为每笔交易都指定了一个简单的贷记/借记方案 —— “向<code class="language-plaintext highlighter-rouge">Bob</code>发送 x <code class="language-plaintext highlighter-rouge">ETH</code>“。</p><p>与<code class="language-plaintext highlighter-rouge">UTxO</code>模型相比，账户模型更具表现力。账户模型支持区块链上的<code class="language-plaintext highlighter-rouge">long lived</code>(长期)合约，可以为生态系统中的每个账户保留自己的状态。<code class="language-plaintext highlighter-rouge">UTxO</code>模型支持长期合约，但<code class="language-plaintext highlighter-rouge">UTxO</code>模型的原语不允许<a href="https://stackoverflow.com/questions/7284/what-is-turing-complete">图灵完备</a>的表达能力。例如，<code class="language-plaintext highlighter-rouge">Alice</code>可以在账户模型区块链上编写智能合约，该合约发行代币并充当银行跟踪持有代币的每个钱包，并在代币持有人使用代币进行交易时执行借记和贷记。</p><p>智能合约充当银行管理和调解交易的想法极大影响了账户模型的并发属性。由于存在中央中介(充当银行的智能合约)的概念，<code class="language-plaintext highlighter-rouge">Alice</code>与<code class="language-plaintext highlighter-rouge">Charlie</code>进行的交易可能会影响到<code class="language-plaintext highlighter-rouge">Bob</code>的交易能力。</p><p>作为一个人为的例子，智能合约可能有一个条款，如果所有账户余额小于10，则阻止任何人进行交易。假设<code class="language-plaintext highlighter-rouge">Alice</code>的余额为11，<code class="language-plaintext highlighter-rouge">Bob</code>的余额为5。还假设<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>都想向<code class="language-plaintext highlighter-rouge">Charlie</code>发送2个硬币。如果<code class="language-plaintext highlighter-rouge">Alice</code>的交易首先执行，<code class="language-plaintext highlighter-rouge">Bob</code>的交易将失败，因为<code class="language-plaintext highlighter-rouge">Alice</code>的余额为<code class="language-plaintext highlighter-rouge">9</code>，<code class="language-plaintext highlighter-rouge">Bob</code>的余额为5，<code class="language-plaintext highlighter-rouge">Charlie</code>的余额为2，这种分配违反了智能合约的”所有余额必须为10或更多”的条件。但是，如果<code class="language-plaintext highlighter-rouge">Bob</code>的交易先执行，它会成功，因为<code class="language-plaintext highlighter-rouge">Alice</code>将拥有超过10个硬币(当前还是<code class="language-plaintext highlighter-rouge">11</code>)。<code class="language-plaintext highlighter-rouge">Bob</code>的第一笔交易成功不会影响<code class="language-plaintext highlighter-rouge">Alice</code>的交易能力，因为仍然会有一个人(<code class="language-plaintext highlighter-rouge">Alice</code>)的余额大于10。这展示了<code class="language-plaintext highlighter-rouge">Alice</code>的交易如何影响<code class="language-plaintext highlighter-rouge">Bob</code>的交易能力(与<code class="language-plaintext highlighter-rouge">UTxO</code>模型相反)，这意味着账户模型中的交易不能像<code class="language-plaintext highlighter-rouge">UTxO</code>模型那样有效地并行化。账户模型中的交易顺序远比<code class="language-plaintext highlighter-rouge">UTxO</code>模型重要。</p><p>账户模型的另一个后果是它使多代币交易比<code class="language-plaintext highlighter-rouge">eUTxO</code>模型更困难(我们将在下一节中详细说明)。 如果<code class="language-plaintext highlighter-rouge">Alice</code>有10个<code class="language-plaintext highlighter-rouge">AliceCoin</code>和10个<code class="language-plaintext highlighter-rouge">BobCoin</code>，并且想将每个硬币中的5个发送给<code class="language-plaintext highlighter-rouge">Bob</code>，她通常会通过2次单独的交易来做到这一点，一笔交易发送5<code class="language-plaintext highlighter-rouge">AliceCoin</code>，另一笔交易发送5<code class="language-plaintext highlighter-rouge">BobCoin</code>。 发生这种情况是因为<code class="language-plaintext highlighter-rouge">AliceCoin</code>和<code class="language-plaintext highlighter-rouge">BobCoin</code>都由独立的智能合约管理，并且它们都彼此独立地管理代币余额。必须独立联系每个合约以执行适当的借贷，通常在两个单独的交易中.</p><p>但是，可以在账户模型中编写第三个智能合约，该合约在执行时会向<code class="language-plaintext highlighter-rouge">AliceCoin</code>和<code class="language-plaintext highlighter-rouge">BobCoin</code>智能合约发出正确的请求。 <code class="language-plaintext highlighter-rouge">Alice</code>理论上可以与<code class="language-plaintext highlighter-rouge">AliceAndBobCoinWrapper</code>合约进行交互，该合约将执行对<code class="language-plaintext highlighter-rouge">AliceCoin</code>和<code class="language-plaintext highlighter-rouge">BobCoin</code>合约的适当调用，但这种范例有几个缺点，例如安全性(<code class="language-plaintext highlighter-rouge">Alice</code>必须授予<code class="language-plaintext highlighter-rouge">AliceAndBobCoinWrapper</code>合约与她的代币交互的权限)、费用(可能这种情况下，使用包装合同比向各自的智能合同发出两个独立的交易更昂贵)、确定性(当合约变得更复杂时更有可能发生故障)和全面性(如果<code class="language-plaintext highlighter-rouge">Alice</code>有第三或第四个想要发送的硬币怎么办?)。</p><h3 id="eutxo模型">eUTxO模型 <a href="#eutxo模型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>扩展的<code class="language-plaintext highlighter-rouge">UTxO</code>模型旨在将账户模型中的智能合约的表现力与<code class="language-plaintext highlighter-rouge">UTxO</code>模型的确定性和可并行性结合起来。 <code class="language-plaintext highlighter-rouge">eUTxO</code>模型具有与<code class="language-plaintext highlighter-rouge">UTxO</code>模型相同的类似现金的直觉，但在构建交易时可以更好地控制如何消耗输入。可以在<a href="https://docs.cardano.org/plutus/eutxo-explainer">Cardano开发人员文档</a>中找到<code class="language-plaintext highlighter-rouge">eUTxO</code>模型的快速摘要，并且可以在<a href="https://iohk.io/en/research/library/papers/the-extended-utxo-model/">IOHK博客</a>上找到介绍该想法及其形式属性的完整科学论文。除了这两个，<code class="language-plaintext highlighter-rouge">IOHK</code>在他们的博客上发表了一篇论文，<a href="https://iohk.io/en/research/library/papers/utxovs-account-based-smart-contract-blockchain-programming-paradigms/">将eUTxO模型与账户模型进行了比较</a>，但这篇论文在数学上非常密集。<code class="language-plaintext highlighter-rouge">IOHK</code>教育总监<code class="language-plaintext highlighter-rouge">Lars Brujnes</code>的这段<a href="https://www.youtube.com/watch?v=bfofA4MM0QE&amp;list=PLK8ah7DzglhgK0bEyELK8EzbW0mn6xavC">视频</a>很好地概述了<code class="language-plaintext highlighter-rouge">UTxO</code>模型、账户模型和<code class="language-plaintext highlighter-rouge">eUTxO</code>模型。</p><h4 id="它是如何工作的">它是如何工作的 <a href="#它是如何工作的" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>让我们首先回顾一下<code class="language-plaintext highlighter-rouge">UTxO</code>模型的一些更深层的机制。 每个<code class="language-plaintext highlighter-rouge">UTxO</code>都有3个字段: 一个表示<code class="language-plaintext highlighter-rouge">UTxO</code>的”大小”的<code class="language-plaintext highlighter-rouge">value</code>、一个帐户的公钥(已授权可以花费该<code class="language-plaintext highlighter-rouge">utxo</code>)和一个验证器函数<code class="language-plaintext highlighter-rouge">v</code>，它接受一个我们称为<code class="language-plaintext highlighter-rouge">redeemer</code>的参数<code class="language-plaintext highlighter-rouge">p</code>。 当一个交易试图消费一个<code class="language-plaintext highlighter-rouge">UTxO</code>时，它必须提供一个<code class="language-plaintext highlighter-rouge">redeemer</code>，使得<code class="language-plaintext highlighter-rouge">v(value, p)=true</code>。通常，此<code class="language-plaintext highlighter-rouge">redeemer</code>是由钱包私钥签名的交易的哈希值。</p><p>验证者将(大约)检查交易是否由与<code class="language-plaintext highlighter-rouge">UTxO</code>中的公钥对应的私钥签署，确保<code class="language-plaintext highlighter-rouge">UTxO</code>只能由授权钱包使用。 可以使用更复杂的<code class="language-plaintext highlighter-rouge">validators</code>(验证器)和<code class="language-plaintext highlighter-rouge">redeemers</code>，但它们仍然无法提供完整的智能合约功能。 使用这种轻量级模型可以执行的脚本类型是有限的。</p><p><code class="language-plaintext highlighter-rouge">eUTxO</code>模型通过几个关键机制扩展了这个模型:</p><ol><li>每个<code class="language-plaintext highlighter-rouge">UTxO</code>都会有一个称为<code class="language-plaintext highlighter-rouge">datum</code>的额外字段<code class="language-plaintext highlighter-rouge">d</code>，它可以持有任意数据(用于跟踪一系列交易中的嵌入状态)<li>除了<code class="language-plaintext highlighter-rouge">redeemer</code>之外，每笔交易<code class="language-plaintext highlighter-rouge">tx</code>的完整信息都会传递给验证者(用于称为合约连续性的概念)<li><code class="language-plaintext highlighter-rouge">validator</code>(验证器)可以有任意逻辑</ol><p>在<code class="language-plaintext highlighter-rouge">eUTxO</code>模型中，为了消耗<code class="language-plaintext highlighter-rouge">UTxO</code>，必须满足<code class="language-plaintext highlighter-rouge">v(value, p, d, tx)=true</code>。这意味着<code class="language-plaintext highlighter-rouge">UTxO</code>的<code class="language-plaintext highlighter-rouge">validator</code>(验证器)必须批准交易<code class="language-plaintext highlighter-rouge">tx</code>可以消费带有<code class="language-plaintext highlighter-rouge">redeemer p</code>和<code class="language-plaintext highlighter-rouge">datum d</code>的<code class="language-plaintext highlighter-rouge">value</code>。</p><p>请记住，可以将区块链视为状态机。我们可以用同样的方式来思考一系列连续的交易。每笔交易都可以演化出一个嵌入在区块链这个更大的状态机中的状态机。为了使一系列交易连续，它们必须强制执行相同的约束。 该<code class="language-plaintext highlighter-rouge">datum</code>使一系列连续的交易能够管理它们自己的状态。将完整交易<code class="language-plaintext highlighter-rouge">tx</code>传递给<code class="language-plaintext highlighter-rouge">validator</code>(验证器)使验证器能够强制交易的输出使用相同的合约代码。</p><h4 id="示例">示例 <a href="#示例" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>让我们通过一个示例来说明<code class="language-plaintext highlighter-rouge">eUTxO</code>模型如何为<code class="language-plaintext highlighter-rouge">datum</code>、<code class="language-plaintext highlighter-rouge">validator</code>(验证器)和合约连续性的概念建立更多的直觉。 让我们来看看<code class="language-plaintext highlighter-rouge">n-of-m</code>多重签名合约。多重签名合约是一个”具有<code class="language-plaintext highlighter-rouge">m</code>个授权人但只需要<code class="language-plaintext highlighter-rouge">n</code>个授权人进行签署就可以执行合约”的合约. 假设<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>想付钱给<code class="language-plaintext highlighter-rouge">Charlie</code>做一些工作。而<code class="language-plaintext highlighter-rouge">Charlie</code>想知道<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>有足够的钱付给他。 在<code class="language-plaintext highlighter-rouge">Charlie</code>完成之前，<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>不想支付工作费用。他们三人可以签订<code class="language-plaintext highlighter-rouge">2-of-3</code>多重签名合同，该合同将持有用于支付<code class="language-plaintext highlighter-rouge">Charlie</code>的资金。 这使<code class="language-plaintext highlighter-rouge">Charlie</code>能够确认<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>拥有足够的资金，同时也让<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Bob</code>控制资金，直到工作完成。 为了进行支付，3人中的任何2人都可以签署合同以释放托管资金。 下面是一个状态转换图，取自<a href="https://iohk.io/en/research/library/papers/the-extended-utxo-model/">eUTxO论文</a>，它概述了多重签名合约的行为方式:</p><p><img data-src="/assets/img/cardano/utxo/n-of-m.png" alt="" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">Holding</code>状态是尚未提出付款的情况。从这个状态，合约可以通过<code class="language-plaintext highlighter-rouge">Propose</code>函数转换到<code class="language-plaintext highlighter-rouge">Collect</code> 状态。一旦进入<code class="language-plaintext highlighter-rouge">Collect</code>状态，就有三种可能的转换: 通过<code class="language-plaintext highlighter-rouge">Add</code>函数返回<code class="language-plaintext highlighter-rouge">Collect</code>，通过<code class="language-plaintext highlighter-rouge">Pay</code>函数返回<code class="language-plaintext highlighter-rouge">Holding</code>，通过<code class="language-plaintext highlighter-rouge">Cancel</code>函数返回<code class="language-plaintext highlighter-rouge">Holding</code>。</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Transaction<th style="text-align: center">消费的UTxO<th style="text-align: left">Redeemer<th style="text-align: left">产生的UTxO<th style="text-align: left">Datum<tbody><tr><td style="text-align: left">创建合约<td style="text-align: center"> <td style="text-align: left"> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">a</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">{}</code><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Propose</code>(提议)付钱给Charlie<td style="text-align: center"><code class="language-plaintext highlighter-rouge">a</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Propose(100, Charlie, 10)</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">b</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Collecting((100, Charlie, 10), {})</code><tr><td style="text-align: left">Charlie签署多签<td style="text-align: center"><code class="language-plaintext highlighter-rouge">b</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Add(sig_charlie)</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">c</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Collecting((100, Charlie, 10), {sig_charlie})</code><tr><td style="text-align: left">Alice签署多签<td style="text-align: center"><code class="language-plaintext highlighter-rouge">c</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Add(sig_alice)</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">d</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Collecting((100, Charlie, 10), {sig_charlie, sig_alice})</code><tr><td style="text-align: left">Charlie完成付款<td style="text-align: center"><code class="language-plaintext highlighter-rouge">d</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">Pay</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">e</code><td style="text-align: left"><code class="language-plaintext highlighter-rouge">{}</code></table></div><p>上面的表格总结了一系列潜在的交易，这些交易使用了上面所示的多签智能合约状态机。下面我将对这些交易进行描述和阐述。</p><p>当<code class="language-plaintext highlighter-rouge">Alice</code>、<code class="language-plaintext highlighter-rouge">Bob</code>和<code class="language-plaintext highlighter-rouge">Charlie</code>达成协议，例如向<code class="language-plaintext highlighter-rouge">Charlie</code>支付<code class="language-plaintext highlighter-rouge">100 ADA</code>时，他们可以启动合约，合约将以<code class="language-plaintext highlighter-rouge">Holding</code>状态开始(此时<code class="language-plaintext highlighter-rouge">datum</code>为空)。<code class="language-plaintext highlighter-rouge">Alice</code>、<code class="language-plaintext highlighter-rouge">Bob</code>和<code class="language-plaintext highlighter-rouge">Charlie</code>的签名被写入到合约代码中，<code class="language-plaintext highlighter-rouge">n</code>的值(等于2)也是如此。此合约启动的结果将是一个<code class="language-plaintext highlighter-rouge">UTxO</code>，我们将其称为<code class="language-plaintext highlighter-rouge">UTxO a</code>，它有一个强制执行有效状态转换的验证器、我们刚刚解释的空的<code class="language-plaintext highlighter-rouge">datum</code>以及最终支付给<code class="language-plaintext highlighter-rouge">Charlie</code>的值。</p><p>一旦<code class="language-plaintext highlighter-rouge">Charlie</code>认为他已经完成了工作，就可以使用redeemer <code class="language-plaintext highlighter-rouge">Propose(100, Charlie, 10)</code>来消费<code class="language-plaintext highlighter-rouge">UTxO a</code>，这意味着<code class="language-plaintext highlighter-rouge">Charlie</code>提议在时间<code class="language-plaintext highlighter-rouge">10</code>之前向自己支付所有<code class="language-plaintext highlighter-rouge">100 ADA</code>。这将创建一个新的<code class="language-plaintext highlighter-rouge">UTxO</code>，我们称之为<code class="language-plaintext highlighter-rouge">b</code>，它有一个值近似<code class="language-plaintext highlighter-rouge">Collecting((100, Charlie, 10), {})</code>的<code class="language-plaintext highlighter-rouge">datum</code>，这意味着<code class="language-plaintext highlighter-rouge">Charlie</code>正试图在时间10之前收集<code class="language-plaintext highlighter-rouge">100</code>个<code class="language-plaintext highlighter-rouge">ADA</code>，但还没有人提交签名。<code class="language-plaintext highlighter-rouge">UTxO b</code>将具有与<code class="language-plaintext highlighter-rouge">UTxO</code>相同的验证器(这是合约的连续性)。</p><p><code class="language-plaintext highlighter-rouge">Charlie</code>现在可以使用redeemer <code class="language-plaintext highlighter-rouge">Add(sig_charlie)</code>提交一个消耗<code class="language-plaintext highlighter-rouge">UTxO b</code>的新交易。由于<code class="language-plaintext highlighter-rouge">Charlie</code>是该合约的授权消费者，这将创建一个新的<code class="language-plaintext highlighter-rouge">UTxO c</code>，其<code class="language-plaintext highlighter-rouge">datum</code>为<code class="language-plaintext highlighter-rouge">Collecting((100, Charlie, 10),{sig_charlie})</code>. 现在<code class="language-plaintext highlighter-rouge">datum</code>表明三个签名者中的一个已授权向<code class="language-plaintext highlighter-rouge">Charlie</code>发送<code class="language-plaintext highlighter-rouge">100 ADA</code>.</p><p>如果<code class="language-plaintext highlighter-rouge">Charlie</code>现在尝试用redeemer <code class="language-plaintext highlighter-rouge">Pay</code>来消费<code class="language-plaintext highlighter-rouge">UTxO c</code>(因为他很贪婪并且想要他的钱)，那么交易将会失败，因为验证器将看到在需要2个签名时却只存在1个签名。同样，如果<code class="language-plaintext highlighter-rouge">Charlie</code>尝试重新添加他的签名以满足<code class="language-plaintext highlighter-rouge">2</code>个签名阈值，他只会浪费他的钱，因为合同会确保不会多次添加相同的签名。<code class="language-plaintext highlighter-rouge">Charlie</code>也可以在生成<code class="language-plaintext highlighter-rouge">UTxO c</code>时尝试更改验证器，但如果他尝试这样做，<code class="language-plaintext highlighter-rouge">UTxO b</code>的验证器会看到这一点并拒绝交易(请记住，在消费以前的输出时，整个交易都会传递给验证器，包括输出)。</p><p>现在，<code class="language-plaintext highlighter-rouge">Alice</code>或<code class="language-plaintext highlighter-rouge">Bob</code>都可以提交带有他们签名的交易来推进状态图。 假设<code class="language-plaintext highlighter-rouge">Alice</code>提交了一笔交易，使用redeemer <code class="language-plaintext highlighter-rouge">Add(sig_alice)</code>来消费<code class="language-plaintext highlighter-rouge">UTxO c</code>。这将创建一个新的<code class="language-plaintext highlighter-rouge">UTxO d</code>，其<code class="language-plaintext highlighter-rouge">datum</code>为<code class="language-plaintext highlighter-rouge">Collecting((100, Charlie, 10), {sig_charlie, sig_alice})</code>。像以前一样，<code class="language-plaintext highlighter-rouge">UTxO d</code>将具有与<code class="language-plaintext highlighter-rouge">UTxO c</code>相同的验证器。</p><p>现在，<code class="language-plaintext highlighter-rouge">Charlie</code>可以使用redeemer <code class="language-plaintext highlighter-rouge">Pay</code>提交消费<code class="language-plaintext highlighter-rouge">UTxO d</code>的交易，以完成对自己的付款。之所以会发生这种情况，是因为redeemer <code class="language-plaintext highlighter-rouge">Pay</code>的唯一条件是有足够多的授权签名已经签署了合同，在本例子中，<code class="language-plaintext highlighter-rouge">Alice</code>和<code class="language-plaintext highlighter-rouge">Charlie</code>都已经成功签署了合同。</p><p>如果付款未在时间<code class="language-plaintext highlighter-rouge">10</code>之前完成，那么任何人都可以通过使用redeemer <code class="language-plaintext highlighter-rouge">Cancel</code>来提交交易以取消付款。这会将合约转换回具有一个空的<code class="language-plaintext highlighter-rouge">redeemer</code>的<code class="language-plaintext highlighter-rouge">Holding</code>状态。然后可以再次开始<code class="language-plaintext highlighter-rouge">proposal</code>(提议)过程。</p><h4 id="eutxo的特性">eUTxO的特性 <a href="#eutxo的特性" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">eUTxO</code>模型保留了<code class="language-plaintext highlighter-rouge">UTxO</code>模型的许多相同属性，例如可扩展性、确定性、隐私性，同时将脚本功能扩展为图灵完备。<code class="language-plaintext highlighter-rouge">eUTxO</code>模型的一个有趣方面是它可能从根本上比帐户模型更具表现力。</p><p>这在<a href="https://iohk.io/en/research/library/papers/chimeric-ledgerstranslating-and-unifying-utxo-based-and-account-based-cryptocurrencies/">IOHK博客上的论文</a>中说:</p><blockquote><p>尽管<code class="language-plaintext highlighter-rouge">translations</code>(翻译/转换)暗示了<code class="language-plaintext highlighter-rouge">accounting</code>(会计/账户)等价性，但命题2和Sec的<code class="language-plaintext highlighter-rouge">translation</code>(翻译)表明，5.2表明通常需要创建多个基于帐户的交易来模拟单个基于<code class="language-plaintext highlighter-rouge">UTXO</code>的交易的效果。这一点很重要: 虽然单个基于<code class="language-plaintext highlighter-rouge">UTXO</code>的交易中的所有价值转移都是以原子方式同时处理的，但不能保证相应的基于账户的交易也是如此, 从理论上讲，他们的执行之间可能存在很大的时间差距。</p></blockquote><p>这篇论文文不讨论<code class="language-plaintext highlighter-rouge">eUTxO</code>模型，但与介绍<a href="https://iohk.io/en/research/library/papers/the-extended-utxo-model/">eUTxO模型</a>的论文相结合时，可以合理地得出结论，<code class="language-plaintext highlighter-rouge">eUTxO</code>模型<em>至少</em>与帐户模型一样具有表现力(并且可能<em>更具</em>表现力)。</p><p>这种表现力的一个例子可以在<code class="language-plaintext highlighter-rouge">Cardano</code>上开发的现实世界实用程序中找到。一项名为<a href="https://dripdropz.io/">DripDropz</a>的服务允许生态系统中的参与者从单一界面领取可供他们使用的空投。</p><p>这在账户模型中是不可能的(我不确定这一点，但我从未见过这样的工具用于基于账户的区块链)。<a href="https://twitter.com/RichardMcCrackn/status/1480945016336154624?s=20&amp;t=hnWiJmUXpIY63J8kTOMfEg">DripDropz</a>能够在一次交易中向<code class="language-plaintext highlighter-rouge">3</code>个不同的参与者发送超过<code class="language-plaintext highlighter-rouge">10</code>种不同的资产。这意味着多达<code class="language-plaintext highlighter-rouge">30</code>个独特的资产(没有两个参与者索取相同的空投)在一次交易中被转移。</p><p>这在账户模型中基本上是不可能的。有可能构建可以执行类似事情的包装合约，但这些包装合同将受到组合爆炸的影响，以涵盖所有可能的资产索赔组合。</p><p><code class="language-plaintext highlighter-rouge">eUTxO</code>模型比<code class="language-plaintext highlighter-rouge">Account</code>模型更易于静态分析和形式验证。这是因为<code class="language-plaintext highlighter-rouge">eUTxO</code>模型中的状态是局部的(即:绑定到每个地址)，而不是全局的。由于帐户模型的全局状态，对帐户模型中给定的智能合约进行形式化分析需要对给定智能合约与之交互的每个合约进行建模。</p><p>例如, 智能合约<code class="language-plaintext highlighter-rouge">a</code>调用智能合约<code class="language-plaintext highlighter-rouge">b</code>调用智能合约<code class="language-plaintext highlighter-rouge">c</code>在<code class="language-plaintext highlighter-rouge">b</code>仍在等待<code class="language-plaintext highlighter-rouge">c</code>完成时回调智能合约<code class="language-plaintext highlighter-rouge">b</code>的形式化分析将非常困难(特别是如果状态可以在各种智能合约调用之间改变).我在形式分析方面的背景不够深入，无法详细描述为什么这很难分析。</p><p>但是，请记住，要使任何交易在<code class="language-plaintext highlighter-rouge">eUTxO</code>模型中有效，必须满足以下条件: <code class="language-plaintext highlighter-rouge">v(value, p, d, tx)=true</code>。验证器是纯函数 —— 它们是幂等的并且没有副作用。尽管<code class="language-plaintext highlighter-rouge">datum</code>可以从一个<code class="language-plaintext highlighter-rouge">UTxO</code>更改为下一个，但将其视为产生新状态更为合理，因为”旧”<code class="language-plaintext highlighter-rouge">UTxO</code>上的<code class="language-plaintext highlighter-rouge">datum</code>不能再被消耗。当进行交易时，旧<code class="language-plaintext highlighter-rouge">datum</code>实际上被丢弃，并在其位置上创建了一个新<code class="language-plaintext highlighter-rouge">datum</code>。纯函数特别适用于形式化和静态分析.</p><p>我们已经多次讨论过帐户模型中的交易必须如何串行完成(因为存在全局状态，智能合约可以相互交互，改变全局状态)。</p><p>我们还将其与常规<code class="language-plaintext highlighter-rouge">UTxO</code>模型进行了比较，该模型支持更多并行处理，因为不共享相同输入(使用相同<code class="language-plaintext highlighter-rouge">UTxO</code>)的交易彼此完全独立。这也适用于<code class="language-plaintext highlighter-rouge">eUTxO</code>模型。不消耗相同输入的交易可以并行处理。这为朴素的第<code class="language-plaintext highlighter-rouge">1</code>层处理能力提供了显着的性能改进，但也使分片在未来更容易实现。 对于绝大多数（也许是全部？）区块链，每个节点和矿工/验证者处理每一笔交易，与分片模式相比，这相对低效和昂贵。分片通过分割区块链的状态，使每个分片负责区块链的一小部分，从而降低节点和矿工/验证器的数据存储和处理需求。由于帐户模型的全局状态，与<code class="language-plaintext highlighter-rouge">UTxO</code>模型相比，使用帐户模型进行分片相对更加困难。</p><p>例如，以太坊有一个相当复杂的<a href="https://eth.wiki/en/sharding/sharding-roadmap">分片路线图</a>，该路线图将于2023年发布(但根据之前估计的及时性，该路线图可能会推迟很久)。<code class="language-plaintext highlighter-rouge">Cardano</code>目前没有详细的分片路线图，但该项目的<a href="https://roadmap.cardano.org/en/basho/">Basho阶段</a>(我们目前正在进行)将使用侧链进行分片解决方案。<a href="https://dcspark.gitbook.io/milkomeda">Milkomeda</a>是一个由<code class="language-plaintext highlighter-rouge">DcSpark</code>开发的侧链，目前在主网上处于测试阶段。</p><p>如前所述，<code class="language-plaintext highlighter-rouge">UTxO</code>模型不如账户模型直观。这意味着制作智能合约的开发人员可能会在使用<code class="language-plaintext highlighter-rouge">eUTxO</code>模型时遇到困难。除了开发人员遇到困难之外，用户在与<code class="language-plaintext highlighter-rouge">eUTxO</code>链上的智能合约交互时可能很难概念化他们在做什么。 不可否认，这两个事实都会减缓<code class="language-plaintext highlighter-rouge">eUTxO</code>模型的采用。但是，由于我们在上面已经表明，<code class="language-plaintext highlighter-rouge">eUTxO</code>模型至少与帐户模型一样具有表达能力，因此有一条清晰的帐户模型兼容性路径。事实上，有几个项目正在筹备中，这将使开发人员从帐户模型迁移到<code class="language-plaintext highlighter-rouge">eUTxO</code>模型变得更加容易: <code class="language-plaintext highlighter-rouge">Milkomeda</code>(<code class="language-plaintext highlighter-rouge">EVM</code>侧链)、<a href="https://runtimeverification.com/the-iele-virtual-machine/">IELE</a>(将为<code class="language-plaintext highlighter-rouge">Mamba</code>提供动力)和<a href="https://docs.google.com/document/d/1s0XLr3EC1aQ8ShdCl78iVQtRbdLHY-n7nGiayp2CPLU/edit">Avoum</a>(使开发人员能够直接为<code class="language-plaintext highlighter-rouge">eUTxO</code>模型编写基于帐户的智能合约)。 一个有益的观察是，曾几何时，在从单核计算到多核计算的过渡期间，编写利用多核的代码很困难，但最终构建了新的工具和抽象，从而显着降低了新的多核范式的复杂性.从基于账户的区块链到基于<code class="language-plaintext highlighter-rouge">eUTxO</code>的区块链的过渡(如果发生的话)也是如此 —— 将构建和发现简化开发过程的工具和抽象。</p><h3 id="结论">结论 <a href="#结论" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">Extended UTxO</code>模型是<code class="language-plaintext highlighter-rouge">IOHK</code>的一项新创新，<code class="language-plaintext highlighter-rouge">IOHK</code>是<code class="language-plaintext highlighter-rouge">Cardano</code>区块链背后的科学和工程公司。<code class="language-plaintext highlighter-rouge">eUTxO</code>模型结合了智能合约在账户模型中的表现力和<code class="language-plaintext highlighter-rouge">UTxO</code>模型的可并行性和确定性。<code class="language-plaintext highlighter-rouge">IOHK</code>的研究表明，<code class="language-plaintext highlighter-rouge">eUTxO</code>模型实际上可能比账户模型更具表现力，这要归功于交易与<code class="language-plaintext highlighter-rouge">UTxO</code>的交互方式的独特属性。除此之外，<code class="language-plaintext highlighter-rouge">eUTxO</code>模型更容易进行形式化和静态分析，这将为用户提供更高程度的保证，即他们与之交互的合约将按预期运行。尽管<code class="language-plaintext highlighter-rouge">eUTxO</code>模型不如帐户模型直观，但目前正在构建工具和抽象，这将有助于弥合差距并简化学习和过渡过程。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cardano/'>Cardano</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/utxo%E6%A8%A1%E5%9E%8B/" class="post-tag no-text-decoration" >UTxO模型</a> <a href="/tags/eutxo%E6%A8%A1%E5%9E%8B/" class="post-tag no-text-decoration" >eUTxO模型</a> <a href="/tags/%E5%88%86%E7%B1%BB%E8%B4%A6/" class="post-tag no-text-decoration" >分类账</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=扩展的UTxO模型 - Lovelace&amp;url=/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=扩展的UTxO模型 - Lovelace&amp;u=/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/&amp;text=扩展的UTxO模型 - Lovelace" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF-purescript-halogen/">前端 purescript halogen</a> <a class="post-tag" href="/tags/eutxo%E6%A8%A1%E5%9E%8B/">eUTxO模型</a> <a class="post-tag" href="/tags/utxo%E6%A8%A1%E5%9E%8B/">UTxO模型</a> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB%E8%B4%A6/">分类账</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"><div class="card-body"> <em class="timeago small" date="2022-01-02T11:04:00+08:00" >Jan 2, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Halogen-07-运行应用程序</h3><div class="text-muted small"><p> 运行应用程序 在本指南的过程中，我们已经多次看到运行Halogen应用程序的标准方法。在本章中，我们将了解运行Halogen应用程序时实际发生的情况以及如何从外部控制正在运行的应用程序。 使用runUI和awaitBody PureScript应用程序使用它们Main模块中的main函数作为它们的入口点。这是Halogen应用程序的标准main函数: module Main where...</p></div></div></a></div><div class="card"> <a href="/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/"><div class="card-body"> <em class="timeago small" date="2022-01-02T11:04:00+08:00" >Jan 2, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Halogen-06-父子组件</h3><div class="text-muted small"><p> 父子组件 Halogen是一个没有偏见的UI库：它允许您创建声明式用户界面，而无需强制执行特定架构。 迄今为止，我们的应用程序由单个Halogen组件组成。您可以将大型应用程序构建为单个组件，并随着应用程序的增长将state、handleAction 和render函数分解为单独的模块。这让您可以在Halogen中使用Elm架构。 但是，Halogen支持具有任意深度组件树的架构。这意...</p></div></div></a></div><div class="card"> <a href="/posts/Halogen-05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A2%E9%98%85/"><div class="card-body"> <em class="timeago small" date="2022-01-02T11:04:00+08:00" >Jan 2, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Halogen-05-生命周期和订阅</h3><div class="text-muted small"><p> 生命周期和订阅 到目前为止，您学到的概念涵盖了您将编写的大多数Halogen组件。大多数组件都有内部状态，呈现HTML元素，并通过在用户单击、悬停或以其他方式与呈现的HTML交互时执行操作来做出响应。 但是actions也可以从其他类型的事件内部产生。下面是一些常见的例子: 您需要在组件启动时运行一个action(例如，您需要执行一个effect来获得您的初始状态)或者当组件从D...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="btn btn-outline-primary" prompt="Older"><p>Halogen-07-运行应用程序</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><script src="https://utteranc.es/client.js" repo="haskell-monad/haskell-monad.github.io" issue-term="title" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/haskell-monad">luna</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF-purescript-halogen/">前端 purescript halogen</a> <a class="post-tag" href="/tags/eutxo%E6%A8%A1%E5%9E%8B/">eUTxO模型</a> <a class="post-tag" href="/tags/utxo%E6%A8%A1%E5%9E%8B/">UTxO模型</a> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB%E8%B4%A6/">分类账</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-YJYEMD99ZB"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-YJYEMD99ZB'); }); </script>
