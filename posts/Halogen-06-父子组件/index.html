<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Halogen-06-父子组件" /><meta name="author" content="purescript-halogen" /><meta property="og:locale" content="en" /><meta name="description" content="父子组件" /><meta property="og:description" content="父子组件" /><link rel="canonical" href="/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/" /><meta property="og:url" content="/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/" /><meta property="og:site_name" content="Lovelace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-02T11:04:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Halogen-06-父子组件" /><meta name="google-site-verification" content="hYrEuDXdYFrLw9klfbDC2ltqWoXRXTNHWmgf9bgO838" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"purescript-halogen"},"headline":"Halogen-06-父子组件","dateModified":"2022-01-02T11:04:00+08:00","datePublished":"2022-01-02T11:04:00+08:00","description":"父子组件","url":"/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/"},"@context":"https://schema.org"}</script><title>Halogen-06-父子组件 | Lovelace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Lovelace"><meta name="application-name" content="Lovelace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?d0140067dd798ddd08fa1dfeecc191bb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Lovelace</a></div><div class="site-subtitle font-italic">所有的善恶都是我，良心一路走来依旧清澈鲜活...</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/haskell-monad" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['haskell.lisp','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Halogen-06-父子组件</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Halogen-06-父子组件</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/purescript-halogen/purescript-halogen/blob/master/docs/guide/05-Parent-Child-Components.md">purescript-halogen</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-01-02T11:04:00+08:00" data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 2, 2022, 11:04 AM +0800" >Jan 2, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10595 words"> <em>58 min</em> read</span></div></div></div><div class="post-content"><h3 id="父子组件">父子组件 <a href="#父子组件" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">Halogen</code>是一个没有偏见的<code class="language-plaintext highlighter-rouge">UI</code>库：它允许您创建声明式用户界面，而无需强制执行特定架构。</p><p>迄今为止，我们的应用程序由单个<code class="language-plaintext highlighter-rouge">Halogen</code>组件组成。您可以将大型应用程序构建为单个组件，并随着应用程序的增长将<code class="language-plaintext highlighter-rouge">state</code>、<code class="language-plaintext highlighter-rouge">handleAction</code> 和<code class="language-plaintext highlighter-rouge">render</code>函数分解为单独的模块。这让您可以在<code class="language-plaintext highlighter-rouge">Halogen</code>中使用<code class="language-plaintext highlighter-rouge">Elm</code>架构。</p><p>但是，<code class="language-plaintext highlighter-rouge">Halogen</code>支持具有任意深度组件树的架构。这意味着您编写的任何组件都可以包含更多组件，每个组件都有自己的状态和行为. 大多数<code class="language-plaintext highlighter-rouge">Halogen</code>应用程序都以这种方式使用组件架构，包括<a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Real World Halogen</a>应用程序。</p><p>当您从单个组件移动到多个组件时，您开始需要机制，以便组件可以相互通信。<code class="language-plaintext highlighter-rouge">Halogen</code>为我们提供了父子组件通信的三种方式:</p><ul><li>父组件可以向子组件发送查询，要么告诉子组件做某事，要么从子组件请求一些信息。<li>父组件为子组件提供它需要的<code class="language-plaintext highlighter-rouge">input</code>，每次父组件渲染时都会重新发送。<li>子组件可以向父组件发射<code class="language-plaintext highlighter-rouge">output</code>消息，在发生重要事件时通知它。</ul><p>这些类型参数在<code class="language-plaintext highlighter-rouge">Component</code>类型中表示，有些还可以在<code class="language-plaintext highlighter-rouge">ComponentHTML</code>和<code class="language-plaintext highlighter-rouge">HalogenM</code>类型中找到。例如，支持<code class="language-plaintext highlighter-rouge">query</code>、<code class="language-plaintext highlighter-rouge">input</code>和<code class="language-plaintext highlighter-rouge">output</code>消息的组件将具有以下<code class="language-plaintext highlighter-rouge">Component</code>类型:</p><pre><code class="language-purescript">component :: forall m. H.Component Query Input Output m
</code></pre><p>您可以将组件与其他组件通信的方式视为其公共接口，而公共接口显示在<code class="language-plaintext highlighter-rouge">Component</code>类型中。</p><p>在本章中，我们将了解:</p><ul><li>如何在你的<code class="language-plaintext highlighter-rouge">Halogen HTML</code>中<code class="language-plaintext highlighter-rouge">render</code>组件<li>组件通信的三种方式: <code class="language-plaintext highlighter-rouge">query</code>、<code class="language-plaintext highlighter-rouge">input</code>和<code class="language-plaintext highlighter-rouge">output</code>消息<li>组件槽、<code class="language-plaintext highlighter-rouge">slot</code>函数和<code class="language-plaintext highlighter-rouge">Slot</code>类型，使这种通信类型安全</ul><p>我们将首先渲染一个没有<code class="language-plaintext highlighter-rouge">query</code>或<code class="language-plaintext highlighter-rouge">output</code>消息的简单子组件。然后，我们将构建使用这些方式进行通信的组件，最后一个示例展示了同时使用所有这些机制的父组件和子组件.</p><p>尝试将示例加载到<code class="language-plaintext highlighter-rouge">Try PureScript</code>中以探索本章中讨论的每个通信机制！</p><h4 id="渲染组件">渲染组件 <a href="#渲染组件" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>我们通过编写返回<code class="language-plaintext highlighter-rouge">Halogen HTML</code>元素的函数来开始本指南。这些函数可以被其他函数用来构建更大的<code class="language-plaintext highlighter-rouge">HTML</code>元素树。</p><p>当我们开始使用组件时，我们开始编写<code class="language-plaintext highlighter-rouge">render</code>函数。从概念上讲，组件通过此函数生成<code class="language-plaintext highlighter-rouge">Halogen HTML</code>并作为其结果，尽管它们还可以维护内部状态和执行<code class="language-plaintext highlighter-rouge">effects</code>等。</p><p>事实上，虽然到目前为止我们在编写<code class="language-plaintext highlighter-rouge">render</code>函数时只使用了<code class="language-plaintext highlighter-rouge">HTML</code>元素，但我们也可以使用组件，就好像它们是生成<code class="language-plaintext highlighter-rouge">HTML</code>的函数一样。这个类比是不完美的，但它可以是一个有用的心理模型，用于理解在编写渲染函数时如何处理组件。</p><p>当一个组件渲染另一个组件时，它被称为<code class="language-plaintext highlighter-rouge">父</code>组件，它渲染的组件被称为<code class="language-plaintext highlighter-rouge">子</code>组件。</p><p>让我们看看如何在我们的<code class="language-plaintext highlighter-rouge">render</code>函数中渲染一个组件，而不是像我们目前看到的那样只渲染<code class="language-plaintext highlighter-rouge">HTML</code>元素。我们将首先编写一个使用辅助函数来渲染按钮的组件。然后，我们将把这个辅助函数变成它自己的组件，我们将调整父组件来渲染这个新的子组件。</p><p>首先，我们将编写一个组件，它使用一个辅助函数来渲染一些<code class="language-plaintext highlighter-rouge">HTML</code>:</p><pre><code class="language-purescript">module Main where

import Prelude

import Halogen as H
import Halogen.HTML as HH

parent :: forall query input output m. H.Component query input output m
parent =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval H.defaultEval
    }
  where
  render :: forall state action. state -&gt; H.ComponentHTML action () m
  render _ = HH.div_ [ button { label: "Click Me" } ]

button :: forall w i. { label :: String } -&gt; HH.HTML w i
button { label } = HH.button [ ] [ HH.text label ]
</code></pre><p>这应该看起来很熟悉。我们有一个简单的组件来渲染一个<code class="language-plaintext highlighter-rouge">div</code>，还有一个辅助函数<code class="language-plaintext highlighter-rouge">button</code>，它将一个给定标签渲染为按钮。需要注意的是，我们的<code class="language-plaintext highlighter-rouge">parent</code>组件为我们的<code class="language-plaintext highlighter-rouge">state</code>和<code class="language-plaintext highlighter-rouge">action</code>保留了类型变量，因为它没有内部状态，也没有任何<code class="language-plaintext highlighter-rouge">action</code>。</p><p>现在，让我们将我们的<code class="language-plaintext highlighter-rouge">button</code>函数变成一个组件以进行演示(在现实世界的应用程序中，它太小了).</p><pre><code class="language-purescript">type Input = { label :: String }

type State = { label :: String }

button :: forall query output m. H.Component query Input output m
button =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval
    }
  where
  initialState :: Input -&gt; State
  initialState input = input

  render :: forall action. State -&gt; H.ComponentHTML action () m
  render { label } = HH.button [ ] [ HH.text label ]
</code></pre><p>我们采取了几个步骤将我们的<code class="language-plaintext highlighter-rouge">button HTML</code>函数转换为<code class="language-plaintext highlighter-rouge">button</code>组件:</p><ul><li>我们将辅助函数的参数转换为组件的<code class="language-plaintext highlighter-rouge">Input</code>类型。父组件负责将此<code class="language-plaintext highlighter-rouge">input</code>提供给我们的组件。我们将在下一节中了解有关<code class="language-plaintext highlighter-rouge">input</code>的更多信息。<li>我们将<code class="language-plaintext highlighter-rouge">HTML</code>移动到组件的<code class="language-plaintext highlighter-rouge">render</code>函数中。<code class="language-plaintext highlighter-rouge">render</code>函数只能访问我们组件的<code class="language-plaintext highlighter-rouge">State</code>类型，所以在我们的<code class="language-plaintext highlighter-rouge">initialState</code>函数中，我们将输入值复制到我们的<code class="language-plaintext highlighter-rouge">state</code>中，以便我们可以渲染它。将<code class="language-plaintext highlighter-rouge">input</code>复制到<code class="language-plaintext highlighter-rouge">state</code>是<code class="language-plaintext highlighter-rouge">Halogen</code>中的常见模式。另请注意，我们的<code class="language-plaintext highlighter-rouge">render</code>函数未指定<code class="language-plaintext highlighter-rouge">action</code>类型(因为我们没有任何<code class="language-plaintext highlighter-rouge">action</code>)并使用<code class="language-plaintext highlighter-rouge">()</code>指示我们没有子组件。<li>我们使用<code class="language-plaintext highlighter-rouge">defaultEval</code>，未修改，作为我们的<code class="language-plaintext highlighter-rouge">EvalSpec</code>，因为这个组件不需要响应内部发生的事件 —— 例如，它没有<code class="language-plaintext highlighter-rouge">action</code>，也没有使用生命周期事件。</ul><p>不过，我们的父组件现在坏了！如果您一直在关注，您现在会看到一个错误:</p><pre><code class="language-purescript">[1/1 TypesDoNotUnify]

  16    render _ = HH.div_ [ button { label: "Click Me" } ]
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  Could not match type

    Component HTML t2 { label :: String }

  with type

    Function
</code></pre><p>不能仅仅通过将组件的<code class="language-plaintext highlighter-rouge">input</code>作为函数参数来渲染组件。即使组件生成普通的<code class="language-plaintext highlighter-rouge">Halogen HTML</code>，它们也可以与父组件通信；出于这个原因，组件需要额外的信息才能像普通元素一样渲染。</p><p>从概念上讲，组件在<code class="language-plaintext highlighter-rouge">HTML</code>树中占据一个<code class="language-plaintext highlighter-rouge">slot</code>。这个插槽是组件可以生成<code class="language-plaintext highlighter-rouge">Halogen HTML</code>的地方，直到它从<code class="language-plaintext highlighter-rouge">DOM</code>中被移除。插槽中的组件可以被认为是一个动态的、有状态的<code class="language-plaintext highlighter-rouge">HTML</code>元素。您可以将这些动态元素与普通<code class="language-plaintext highlighter-rouge">Halogen HTML</code>元素自由混合，但动态元素需要更多信息。</p><p>这些额外的信息来自<code class="language-plaintext highlighter-rouge">ComponentHTML</code>中使用的<code class="language-plaintext highlighter-rouge">slot</code>函数和<code class="language-plaintext highlighter-rouge">Slot</code>类型，到目前为止，我们将它们留作空行, <code class="language-plaintext highlighter-rouge">()</code>。稍后我们将更多地讨论在插槽中渲染组件，但现在让我们开始编译。</p><p>我们可以通过<code class="language-plaintext highlighter-rouge">slot</code>函数在<code class="language-plaintext highlighter-rouge">slot</code>中渲染我们的组件来修复我们的<code class="language-plaintext highlighter-rouge">render</code>函数。我们还将更新<code class="language-plaintext highlighter-rouge">ComponentHTML</code>中的<code class="language-plaintext highlighter-rouge">slot</code>类型，以包含我们现在必须支持的<code class="language-plaintext highlighter-rouge">Halogen HTML</code>组件。此差异演示了渲染<code class="language-plaintext highlighter-rouge">HTML</code>元素和<code class="language-plaintext highlighter-rouge">渲染</code>组件之间的差异:</p><pre><code class="language-purescript">+ import Type.Proxy (Proxy(..))
+
+ type Slots = ( button :: forall query. H.Slot query Void Int )
+
+ _button = Proxy :: Proxy "button"

  parent :: forall query input output m. H.Component query input output m
  parent =
    H.mkComponent
      { initialState: identity
      , render
      , eval: H.mkEval H.defaultEval
      }
    where
-   render :: forall state action. state -&gt; H.ComponentHTML action () m
+   render :: forall state action. state -&gt; H.ComponentHTML action Slots m
    render _ =
-     HH.div_ [ button { label: "Click Me" } ]
+     HH.div_ [ HH.slot_ _button 0 button { label: "Click Me" } ]
</code></pre><p>我们的父组件现在正在渲染一个子组件 —— 我们的按钮组件。渲染一个组件引入了两个大的变化:</p><ul><li>我们使用了<code class="language-plaintext highlighter-rouge">slot_</code>函数来渲染组件，它带有几个我们还没有探索过的参数。其中两个参数是<code class="language-plaintext highlighter-rouge">button</code>组件本身和它需要作为<code class="language-plaintext highlighter-rouge">input</code>的标签。<li>我们添加了一个名为<code class="language-plaintext highlighter-rouge">Slots</code>的新类型，这是一个<code class="language-plaintext highlighter-rouge">row</code>包含我们的<code class="language-plaintext highlighter-rouge">button</code>组件的标签，其值为<code class="language-plaintext highlighter-rouge">H.Slot</code>，我们在<code class="language-plaintext highlighter-rouge">ComponentHTML</code>中使用了这个新类型，而不是我们之前看到的空行<code class="language-plaintext highlighter-rouge">()</code>。</ul><p><code class="language-plaintext highlighter-rouge">slot</code>和<code class="language-plaintext highlighter-rouge">slot_</code>函数以及<code class="language-plaintext highlighter-rouge">Slot</code>类型允许您在<code class="language-plaintext highlighter-rouge">Halogen HTML</code>中渲染一个<code class="language-plaintext highlighter-rouge">stateful</code>、<code class="language-plaintext highlighter-rouge">effectful</code>的子组件，就像它是任何其他<code class="language-plaintext highlighter-rouge">HTML</code>元素一样。但是为什么有这么多参数和类型涉及到这样做呢？为什么我们不能用它的<code class="language-plaintext highlighter-rouge">input</code>调用<code class="language-plaintext highlighter-rouge">button</code>？</p><p>答案是<code class="language-plaintext highlighter-rouge">Halogen</code>为父子组件提供了两种相互通信的方式，我们需要确保这种通信是类型安全的。<code class="language-plaintext highlighter-rouge">slot</code>函数允许我们:</p><ul><li>决定如何通过标签(类型级别的字符串<code class="language-plaintext highlighter-rouge">button</code>，我们在术语级别用代理<code class="language-plaintext highlighter-rouge">Proxy :: Proxy "button"</code>表示)和唯一标识符来标识特定组件(在本例中为整数<code class="language-plaintext highlighter-rouge">0</code>)以便我们可以向它发送查询。这是父组件与子组件之间必不可少的沟通形式。<li>渲染组件(<code class="language-plaintext highlighter-rouge">button</code>)并为其提供<code class="language-plaintext highlighter-rouge">input</code>（<code class="language-plaintext highlighter-rouge">{ label: "Click Me" }</code>），每次父组件渲染时都会重新发送，以防<code class="language-plaintext highlighter-rouge">input</code>随时间发生变化。这是一种从父组件到子组件的声明式沟通形式。<li>决定如何处理来自子组件的<code class="language-plaintext highlighter-rouge">output</code>消息。<code class="language-plaintext highlighter-rouge">slot</code>函数允许您为子组件的<code class="language-plaintext highlighter-rouge">output</code>提供<code class="language-plaintext highlighter-rouge">handler</code>处理程序，而<code class="language-plaintext highlighter-rouge">slot_</code>函数可以在子组件没有任何<code class="language-plaintext highlighter-rouge">output</code>或您想忽略它们时使用。这是子组件与父组件之间的沟通。</ul><p><code class="language-plaintext highlighter-rouge">slot</code>和<code class="language-plaintext highlighter-rouge">slot_</code>函数以及<code class="language-plaintext highlighter-rouge">H.Slot</code>类型让我们以类型安全的方式管理这三种通信机制。在本章的其余部分，我们将重点关注父组件和子组件如何相互通信，并在此过程中探索<code class="language-plaintext highlighter-rouge">slots</code>和<code class="language-plaintext highlighter-rouge">slot</code>类型。</p><h4 id="组件间通信">组件间通信 <a href="#组件间通信" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>当您从使用一个组件转向使用多个组件时，您很快就会需要某种方式让它们相互通信。在<code class="language-plaintext highlighter-rouge">Halogen</code>中，父组件和子组件可以通过三种方式直接通信:</p><ul><li>父组件可以向子组件提供<code class="language-plaintext highlighter-rouge">input</code>。每次父组件渲染时，它都会再次发送<code class="language-plaintext highlighter-rouge">input</code>，然后由子组件决定如何处理新<code class="language-plaintext highlighter-rouge">input</code>。<li>子组件可以向父组件发送<code class="language-plaintext highlighter-rouge">output</code>消息，类似于我们目前使用订阅的方式。子组件可以在发生重要事件时通知父组件，就像<code class="language-plaintext highlighter-rouge">modal</code>关闭或提交表单一样，然后父组件可以决定要做什么。<li>父组件可以查询子组件，或者告诉它做某事，或者通过从它那里请求一些信息。父组件可以决定何时需要子组件做某事或给它一些信息，然后由子组件来处理<code class="language-plaintext highlighter-rouge">query</code>。</ul><p>这三种机制为您提供了多种组件之间通信的方式。让我们简要探讨一下这三种机制，然后我们将看到您为组件定义的<code class="language-plaintext highlighter-rouge">slot</code>函数和<code class="language-plaintext highlighter-rouge">slot</code>类型如何帮助您以类型安全的方式使用它们。</p><h5 id="input">Input <a href="#input" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>父组件可以向子组件提供<code class="language-plaintext highlighter-rouge">input</code>，该<code class="language-plaintext highlighter-rouge">input</code>在每次渲染时发送。我们已经多次看到这种情况 —— <code class="language-plaintext highlighter-rouge">input</code>类型用于生成子组件的初始状态。在介绍本章的示例中，我们的<code class="language-plaintext highlighter-rouge">button</code>组件从父组件接收了它的标签。</p><p>到目前为止，我们只使用<code class="language-plaintext highlighter-rouge">input</code>来生成我们的初始状态。但是一旦创建了初始状态，<code class="language-plaintext highlighter-rouge">input</code>就不会停止。<code class="language-plaintext highlighter-rouge">input</code>在每次渲染时再次发送，子组件可以通过其<code class="language-plaintext highlighter-rouge">eval</code>规范中的<code class="language-plaintext highlighter-rouge">receive</code>函数处理新的<code class="language-plaintext highlighter-rouge">input</code>。</p><pre><code class="language-purescript">receive :: input -&gt; Maybe action
</code></pre><p><code class="language-plaintext highlighter-rouge">eval</code>规范中的<code class="language-plaintext highlighter-rouge">receive</code>函数应该提醒你<code class="language-plaintext highlighter-rouge">initialize</code>和<code class="language-plaintext highlighter-rouge">finalize</code>，当组件创建和销毁时它让你选择一个<code class="language-plaintext highlighter-rouge">action</code>来评估. 以同样的方式，当父组件发生新的<code class="language-plaintext highlighter-rouge">input</code>时，<code class="language-plaintext highlighter-rouge">receive</code>函数让您可以选择一个<code class="language-plaintext highlighter-rouge">action</code>来评估。</p><p>默认情况下，当接收到新<code class="language-plaintext highlighter-rouge">input</code>时，<code class="language-plaintext highlighter-rouge">Halogen</code>的<code class="language-plaintext highlighter-rouge">defaultSpec</code>不提供要评估的<code class="language-plaintext highlighter-rouge">action</code>。如果您的子组件在收到初始值后不需要做任何事情，那么您可以保持原样。例如，一旦我们的按钮收到它的标签并将其复制到<code class="language-plaintext highlighter-rouge">state</code>中，就没有必要继续监听<code class="language-plaintext highlighter-rouge">input</code>，以防它随着时间的推移而改变。</p><p>每次父组件渲染时接收新<code class="language-plaintext highlighter-rouge">input</code>的能力是一项强大的功能。这意味着父组件可以声明性地为子组件提供值。父组件还有其他方式与子组件通信，但<code class="language-plaintext highlighter-rouge">input</code>的声明性使其成为大多数情况下的最佳选择。</p><p>让我们通过重新审视介绍中的示例来具体说明这一点。在这个版本中，我们的<code class="language-plaintext highlighter-rouge">button</code>是未改变的 —— 它接收它的标签作为<code class="language-plaintext highlighter-rouge">input</code>并使用它来设置它的初始状态 —— 但是我们的父组件已经改变了. 我们的父组件现在在初始化时启动一个计时器，每秒增加一个计数，并将状态中的计数用作按钮的标签。</p><p>简而言之，我们按钮的<code class="language-plaintext highlighter-rouge">input</code>将每秒钟重新发送一次。尝试将其粘贴到<a href="https://try.purescript.org/">Try PureScript</a>中，看看会发生什么 —— 我们按钮的标签是否每秒更新一次？</p><pre><code class="language-purescript">module Main where

import Prelude

import Control.Monad.Rec.Class (forever)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Aff (Milliseconds(..))
import Effect.Aff as Aff
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.HTML as HH
import Halogen.Subscription as HS
import Halogen.VDom.Driver (runUI)
import Type.Proxy (Proxy(..))

main :: Effect Unit
main = runHalogenAff do
  body &lt;- awaitBody
  runUI parent unit body

type Slots = ( button :: forall q. H.Slot q Void Unit )

_button = Proxy :: Proxy "button"

type ParentState = { count :: Int }

data ParentAction = Initialize | Increment

parent :: forall query input output m. MonadAff m =&gt; H.Component query input output m
parent =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        }
    }
  where
  initialState :: input -&gt; ParentState
  initialState _ = { count: 0 }

  render :: ParentState -&gt; H.ComponentHTML ParentAction Slots m
  render { count } =
    HH.div_ [ HH.slot_ _button unit button { label: show count } ]

  handleAction :: ParentAction -&gt; H.HalogenM ParentState ParentAction Slots output m Unit
  handleAction = case _ of
    Initialize -&gt; do
      { emitter, listener } &lt;- H.liftEffect HS.create
      void $ H.subscribe emitter
      void
        $ H.liftAff
        $ Aff.forkAff
        $ forever do
            Aff.delay $ Milliseconds 1000.0
            H.liftEffect $ HS.notify listener Increment
    Increment -&gt; H.modify_ \st -&gt; st { count = st.count + 1 }

-- 现在我们转向我们的子组件，按钮

type ButtonInput = { label :: String }

type ButtonState = { label :: String }

button :: forall query output m. H.Component query ButtonInput output m
button =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval H.defaultEval
    }
  where
  initialState :: ButtonInput -&gt; ButtonState
  initialState { label } = { label }

  render :: forall action. ButtonState -&gt; H.ComponentHTML action () m
  render { label } = HH.button_ [ HH.text label ]
</code></pre><p>如果您将其加载到<code class="language-plaintext highlighter-rouge">Try PureScript</code>中，您将看到我们的按钮…永远不会改变！即使父组件每秒都在向它发送新<code class="language-plaintext highlighter-rouge">input</code>(每​​次父组件重新渲染)，我们的子组件也永远不会收到它。仅仅接受<code class="language-plaintext highlighter-rouge">input</code>是不够的, 我们还需要明确决定每次收到它时要做什么。</p><p>尝试用这个修改后的代码替换按钮代码以查看不同之处:</p><pre><code class="language-purescript">data ButtonAction = Receive ButtonInput

type ButtonInput = { label :: String }

type ButtonState = { label :: String }

button :: forall query output m. H.Component query ButtonInput output m
button =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , receive = Just &lt;&lt;&lt; Receive
        }
    }
  where
  initialState :: ButtonInput -&gt; ButtonState
  initialState { label } = { label }

  render :: ButtonState -&gt; H.ComponentHTML ButtonAction () m
  render { label } = HH.button_ [ HH.text label ]

  handleAction :: ButtonAction -&gt; H.HalogenM ButtonState ButtonAction () output m Unit
  handleAction = case _ of
    -- 当我们收到新的input时，我们会更新状态中的`label`字段。
    Receive input -&gt;
      H.modify_ _ { label = input.label }
</code></pre><p>我们在新版本中进行了几处更改，以确保我们与来自父组件的<code class="language-plaintext highlighter-rouge">input</code>保持同步:</p><ul><li>我们添加了一个新动作<code class="language-plaintext highlighter-rouge">Receive</code>，一个接受<code class="language-plaintext highlighter-rouge">Input</code>类型作为其参数的构造函数。然后我们通过在接收到新<code class="language-plaintext highlighter-rouge">input</code>时更新我们的状态来在我们的<code class="language-plaintext highlighter-rouge">handleAction</code>函数中处理这个<code class="language-plaintext highlighter-rouge">action</code>。<li>我们在<code class="language-plaintext highlighter-rouge">eval</code>规范中添加了一个新字段，<code class="language-plaintext highlighter-rouge">receive</code>，它包含一个函数，每次接收到新<code class="language-plaintext highlighter-rouge">input</code>时都会调用该函数。我们的函数会返回我们的<code class="language-plaintext highlighter-rouge">Receive</code>操作，以便对其进行评估。</ul><p>此更改足以让我们的子组件订阅来自父组件的新<code class="language-plaintext highlighter-rouge">input</code>。您现在应该看到我们按钮的标签每秒更新一次. 作为练习，您可以用<code class="language-plaintext highlighter-rouge">const Nothing</code>替换我们的<code class="language-plaintext highlighter-rouge">receive</code>函数，以再次查看<code class="language-plaintext highlighter-rouge">input</code>是如何被忽略的。</p><h5 id="output消息">Output消息 <a href="#output消息" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>有时一个事件发生在 它不应该自己处理的 子组件中。</p><p>例如，假设我们正在编写一个<code class="language-plaintext highlighter-rouge">modal</code>组件，当用户单击以关闭<code class="language-plaintext highlighter-rouge">modal</code>时，我们需要评估一些代码。为了保持这个<code class="language-plaintext highlighter-rouge">modal</code>的灵活性，我们希望父组件决定当<code class="language-plaintext highlighter-rouge">modal</code>关闭时应该发生什么。</p><p>在<code class="language-plaintext highlighter-rouge">Halogen</code>中，我们通过设计<code class="language-plaintext highlighter-rouge">modal</code>(子组件)来向父组件发出<code class="language-plaintext highlighter-rouge">output</code>消息来处理这种情况。然后，父组件可以像处理其<code class="language-plaintext highlighter-rouge">handleAction</code>函数中的任何其他操作一样处理该消息。从概念上讲，就好像子组件是父组件自动订阅的订阅。</p><p>具体来说，我们的<code class="language-plaintext highlighter-rouge">modal</code>可以向父组件提出一个<code class="language-plaintext highlighter-rouge">Closed</code>输出。然后，父级可以更改其状态以指示不应再显示<code class="language-plaintext highlighter-rouge">modal</code>，并在下一次渲染时将<code class="language-plaintext highlighter-rouge">modal</code>从<code class="language-plaintext highlighter-rouge">DOM</code>中删除。</p><p>作为一个小例子，让我们考虑如何设计一个按钮，让父组件决定点击它时要做什么:</p><pre><code class="language-purescript">module Button where

-- 这个组件可以通知父组件一个事件，`Clicked`
data Output = Clicked

-- 这个组件可以处理一个内部事件，`Click`
data Action = Click

-- 我们的output类型显示在我们的 `Component` 类型中
button :: forall query input m. H.Component query input Output m
button =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  render _ =
    HH.button
      [ HE.onClick \_ -&gt; Click ]
      [ HH.text "Click me" ]

  -- 我们的output类型也显示在我们的 `HalogenM` 类型中, 因为这是我们可以发出这些output消息的地方。
  handleAction :: forall state. Action -&gt; H.HalogenM state Action () Output m Unit
  handleAction = case _ of
    -- 当按钮被点击时，我们通过使用`H.raise`发出它来通知父组件`Clicked`事件已经发生。
    Click -&gt;
      H.raise Clicked
</code></pre><p>我们采取了一些步骤来实现此<code class="language-plaintext highlighter-rouge">output</code>消息。</p><ul><li>我们添加了一个<code class="language-plaintext highlighter-rouge">Output</code>类型，它描述了我们的组件可以发出哪些<code class="language-plaintext highlighter-rouge">output</code>消息. 我们在<code class="language-plaintext highlighter-rouge">Component</code>类型中使用该类型是因为它是组件公共接口的一部分，而我们的<code class="language-plaintext highlighter-rouge">HalogenM</code>类型使用它是因为这是我们可以实际发出<code class="language-plaintext highlighter-rouge">output</code>消息的地方。<li>我们添加了一个带有<code class="language-plaintext highlighter-rouge">Click</code>构造函数的<code class="language-plaintext highlighter-rouge">Action</code>类型来处理<code class="language-plaintext highlighter-rouge">Halogen HTML</code>中的单击事件.<li>我们通过向父组件发送<code class="language-plaintext highlighter-rouge">output</code>消息来处理我们的<code class="language-plaintext highlighter-rouge">handleAction</code>中的<code class="language-plaintext highlighter-rouge">Click</code>操作。您可以使用<code class="language-plaintext highlighter-rouge">H.raise</code>函数发出<code class="language-plaintext highlighter-rouge">output</code>消息。</ul><p>我们现在知道组件如何发出<code class="language-plaintext highlighter-rouge">output</code>消息。现在，让我们看看如何处理来自子组件的<code class="language-plaintext highlighter-rouge">output</code>消息。有以下三点需要牢记:</p><ul><li>当您渲染一个子组件时，您需要将它添加到您的<code class="language-plaintext highlighter-rouge">slots</code>类型中，然后在您的<code class="language-plaintext highlighter-rouge">ComponentHTML</code>和<code class="language-plaintext highlighter-rouge">HalogenM</code>类型中使用它。您添加的类型将包括子组件的<code class="language-plaintext highlighter-rouge">output</code>消息类型，它允许编译器验证您的处理程序。<li>当您使用<code class="language-plaintext highlighter-rouge">slot</code>函数渲染子组件时，您可以提供一个应在出现新<code class="language-plaintext highlighter-rouge">output</code>时评估的<code class="language-plaintext highlighter-rouge">action</code>。这类似于<code class="language-plaintext highlighter-rouge">initialize</code>等生命周期函数如何接受一个<code class="language-plaintext highlighter-rouge">action</code>来评估组件何时初始化。<li>然后，您需要在您的<code class="language-plaintext highlighter-rouge">handleAction</code>添加一个<code class="language-plaintext highlighter-rouge">case</code>操作，用于(您添加的<code class="language-plaintext highlighter-rouge">action</code>来)处理子组件的<code class="language-plaintext highlighter-rouge">output</code>。</ul><p>让我们通过编写一个<code class="language-plaintext highlighter-rouge">slot</code>类型来开始编写我们的父组件:</p><pre><code class="language-purescript">module Parent where

import Button as Button

type Slots = ( button :: forall query. H.Slot query Button.Output Int )

-- 我们可以使用符号代理来引用`button`标签，这是一种在值级别引用像`button`这样的类型级别字符串的方式。
-- 我们定义这个是为了方便，所以我们可以使用`_button`在slot类型中引用它的标签，而不是一遍遍地写`Proxy`。
_button = Proxy :: Proxy "button"
</code></pre><p>我们的<code class="language-plaintext highlighter-rouge">slot</code>类型是一个<code class="language-plaintext highlighter-rouge">row</code>，其中每个标签指定我们支持的特定类型的子组件，在每种情况下都使用类型<code class="language-plaintext highlighter-rouge">H.Slot</code>:</p><pre><code class="language-purescript">H.Slot query output id
</code></pre><p>该类型记录了可以发送到该类型组件的<code class="language-plaintext highlighter-rouge">queries</code>、我们可以从该组件处理的<code class="language-plaintext highlighter-rouge">output</code>消息, 以及我们可以用来唯一标识单个组件的类型。</p><p>例如，考虑一下我们可以渲染<code class="language-plaintext highlighter-rouge">10</code>个这样的按钮组件 —— 您如何知道向哪个组件发送查询？这就是插槽<code class="language-plaintext highlighter-rouge">id</code>发挥作用的地方。我们将在讨论查询时了解更多相关信息。</p><p>我们的父组件的<code class="language-plaintext highlighter-rouge">row</code>类型清楚地表明我们可以支持一种类型的子组件，我们可以通过符号<code class="language-plaintext highlighter-rouge">button</code>和<code class="language-plaintext highlighter-rouge">Int</code>类型的标识符来引用它. 我们无法向该组件发送<code class="language-plaintext highlighter-rouge">query</code>，因为类型变量保持打开状态。但它可以向我们发送<code class="language-plaintext highlighter-rouge">Button.Output</code>类型的<code class="language-plaintext highlighter-rouge">output</code>。</p><p>接下来，我们需要提供一个<code class="language-plaintext highlighter-rouge">action</code>来处理这些<code class="language-plaintext highlighter-rouge">output</code>:</p><pre><code class="language-purescript">data Action = HandleButton Button.Output
</code></pre><p>当这个<code class="language-plaintext highlighter-rouge">action</code>发生在我们的组件中时，我们可以解开它以获取<code class="language-plaintext highlighter-rouge">Button.Output</code>值并使用它来决定要评估的代码。现在我们已经处理了我们的<code class="language-plaintext highlighter-rouge">slot</code>和<code class="language-plaintext highlighter-rouge">action</code>类型，让我们编写我们的父组件:</p><pre><code class="language-purescript">parent :: forall query input output m. H.Component query input output m
parent =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  render :: forall state. state -&gt; H.ComponentHTML Action Slots m
  render _ =
    HH.div_
      [ HH.slot _button 0 button unit HandleButton ]

  handleAction :: forall state. Action -&gt; H.HalogenM state Action Slots output m Unit
  handleAction = case _ of
    HandleButton output -&gt;
      case output of
        Button.Clicked -&gt; do
          ...
</code></pre><p>您会注意到我们的<code class="language-plaintext highlighter-rouge">Slots</code>类型现在已用于<code class="language-plaintext highlighter-rouge">ComponentHTML</code>类型和<code class="language-plaintext highlighter-rouge">HalogenM</code>类型。此外，现在每当<code class="language-plaintext highlighter-rouge">Button.Clicked</code>事件在子组件中发生时都会通知该组件，这让父组件可以评估它想要的任何代码作为响应。</p><p>就是这样！您现在知道如何将<code class="language-plaintext highlighter-rouge">output</code>消息从子组件提升到父组件以及如何在父组件中处理这些消息. 这是子组件与父组件通信的主要方式。现在让我们看看父组件如何向子组件发送信息。</p><h5 id="queries">Queries <a href="#queries" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>查询表示父组件可以发送给子组件的命令或请求。它们类似于<code class="language-plaintext highlighter-rouge">action</code>，并使用类似于<code class="language-plaintext highlighter-rouge">handleAction</code>函数的<code class="language-plaintext highlighter-rouge">handleQuery</code>函数进行处理。但它们是从组件外部产生的，而不是像<code class="language-plaintext highlighter-rouge">action</code>那样在组件内部，这意味着它们是组件公共接口的一部分。</p><p>当父组件需要控制事件何时发生而不是子组件时，查询最有用。例如:</p><ul><li>父组件可以告诉表单提交，而不是等待用户单击提交按钮。<li>父组件可以从<code class="language-plaintext highlighter-rouge">autocomplete</code>请求当前的选择，而不是在做出选择时等待子组件的<code class="language-plaintext highlighter-rouge">output</code>消息.</ul><p>查询是父组件强制控制子组件的一种方式。正如我们在两个示例中所介绍的，有两种常见的查询样式: 当父组件命令子组件做某事时的<code class="language-plaintext highlighter-rouge">tell</code>风格的查询，以及当父组件想要从子组件获取信息时的<code class="language-plaintext highlighter-rouge">request</code>风格的查询。</p><p>父组件可以发送<code class="language-plaintext highlighter-rouge">query</code>，但子组件定义<code class="language-plaintext highlighter-rouge">query</code>并处理<code class="language-plaintext highlighter-rouge">query</code>。这使得<code class="language-plaintext highlighter-rouge">query</code>在概念上类似于<code class="language-plaintext highlighter-rouge">action</code>: 就像如何定义<code class="language-plaintext highlighter-rouge">Action</code>类型并使用<code class="language-plaintext highlighter-rouge">handleAction</code>为组件处理<code class="language-plaintext highlighter-rouge">action</code>一样，您可以为<code class="language-plaintext highlighter-rouge">queries</code>定义<code class="language-plaintext highlighter-rouge">Query</code>类型和<code class="language-plaintext highlighter-rouge">handleQuery</code>函数。</p><p>下面是一个查询类型的简短示例，其中包括<code class="language-plaintext highlighter-rouge">tell-style</code>和<code class="language-plaintext highlighter-rouge">request-style</code>查询:</p><pre><code class="language-purescript">data Query a
  = Tell a
  | Request (Boolean -&gt; a)
</code></pre><p>我们可以将这个查询解释为”一个父组件可以使用<code class="language-plaintext highlighter-rouge">tell</code>函数告诉这个组件做一些事情，也可以使用<code class="language-plaintext highlighter-rouge">request</code>函数从这个组件请求一个布尔值.” 当我们实现查询类型时，请记住<code class="language-plaintext highlighter-rouge">a</code>类型参数应出现在每个构造函数中。它应该是<code class="language-plaintext highlighter-rouge">tell</code>风格查询的最后一个参数，并且是<code class="language-plaintext highlighter-rouge">request</code>风格查询的函数类型的结果。</p><p>在<code class="language-plaintext highlighter-rouge">eval</code>规范中使用<code class="language-plaintext highlighter-rouge">handleQuery</code>函数处理<code class="language-plaintext highlighter-rouge">query</code>，就像使用<code class="language-plaintext highlighter-rouge">handleAction</code>函数处理<code class="language-plaintext highlighter-rouge">action</code>一样. 让我们为我们的自定义数据类型编写一个<code class="language-plaintext highlighter-rouge">handleQuery</code>函数，假设已经定义了一些<code class="language-plaintext highlighter-rouge">state</code>、<code class="language-plaintext highlighter-rouge">action</code>和<code class="language-plaintext highlighter-rouge">output</code>类型:</p><pre><code class="language-purescript">handleQuery :: forall a m. Query a -&gt; H.HalogenM State Action () Output m (Maybe a)
handleQuery = case _ of
  Tell a -&gt;
    -- ... 做一些事情，然后返回我们收到的`a`
    pure (Just a)

  Request reply -&gt;
    -- ... 做一些事情，然后将请求的`Boolean`提供给`reply`函数以生成我们需要返回的`a`
    pure (Just (reply true))
</code></pre><p><code class="language-plaintext highlighter-rouge">handleQuery</code>函数接受类型为<code class="language-plaintext highlighter-rouge">Query a</code>的<code class="language-plaintext highlighter-rouge">query</code>并生成一些返回<code class="language-plaintext highlighter-rouge">Maybe a</code>的<code class="language-plaintext highlighter-rouge">HalogenM</code>代码。这就是为什么我们的<code class="language-plaintext highlighter-rouge">query</code>类型的每个构造函数都需要包含一个<code class="language-plaintext highlighter-rouge">a</code>: 我们需要在<code class="language-plaintext highlighter-rouge">handleQuery</code>中返回它。</p><p>当我们收到一个<code class="language-plaintext highlighter-rouge">tell</code>风格的查询时，我们可以将我们收到的<code class="language-plaintext highlighter-rouge">a</code>包装在<code class="language-plaintext highlighter-rouge">Just</code>中以返回它，就像我们在<code class="language-plaintext highlighter-rouge">handleQuery</code>中处理<code class="language-plaintext highlighter-rouge">Tell a</code>的<code class="language-plaintext highlighter-rouge">case</code>所做的那样.</p><p>但是，当我们收到<code class="language-plaintext highlighter-rouge">request</code>风格的查询时，我们必须做更多的工作。我们接收的不是一个我们可以返回的<code class="language-plaintext highlighter-rouge">a</code>值，而是一个函数，该函数会给我们一个<code class="language-plaintext highlighter-rouge">a</code>然后我们可以返回. 例如，在我们的<code class="language-plaintext highlighter-rouge">Request (Boolean -&gt; a)</code>示例中，我们收到一个函数(当我们将它应用于<code class="language-plaintext highlighter-rouge">Boolean</code>时，它会给我们一个<code class="language-plaintext highlighter-rouge">a</code>). 按照惯例，当您对<code class="language-plaintext highlighter-rouge">request</code>风格的查询进行模式匹配时，此函数称为<code class="language-plaintext highlighter-rouge">reply</code>。在<code class="language-plaintext highlighter-rouge">handleQuery</code>中，我们给这个函数一个<code class="language-plaintext highlighter-rouge">true</code>以获取<code class="language-plaintext highlighter-rouge">a</code>，然后将<code class="language-plaintext highlighter-rouge">a</code>包裹在<code class="language-plaintext highlighter-rouge">Just</code>中以返回它。</p><p><code class="language-plaintext highlighter-rouge">request</code>风格的查询起初可能看起来很奇怪。但是该风格允许我们的<code class="language-plaintext highlighter-rouge">query</code>类型返回多种类型的值，而不是只返回一种类型的值。以下是一些返回不同内容的不同请求类型:</p><pre><code class="language-purescript">data Requests a
  = GetInt (Int -&gt; a)
  | GetRecord ({ a :: Int, b :: String } -&gt; a)
  | GetString (String -&gt; a)
  | ...
</code></pre><p>父组件可以使用<code class="language-plaintext highlighter-rouge">GetInt</code>从我们的组件中检索一个<code class="language-plaintext highlighter-rouge">Int</code>，使用<code class="language-plaintext highlighter-rouge">GetString</code>从我们的组件中检索一个<code class="language-plaintext highlighter-rouge">String</code>，等等。您可以考虑<code class="language-plaintext highlighter-rouge">query</code>类型返回的<code class="language-plaintext highlighter-rouge">a</code>类型，而<code class="language-plaintext highlighter-rouge">request</code>风格的查询是一种让<code class="language-plaintext highlighter-rouge">a</code>成为许多不同可能类型的方法。稍后我们将看到如何从父组件执行此操作。</p><p>让我们看另一个小例子，它演示了如何在组件中定义和处理<code class="language-plaintext highlighter-rouge">queries</code>:</p><pre><code class="language-purescript">-- 该组件可以被告知`increment`或可以回答当前`count`的请求
data Query a
  = Increment a
  | GetCount (Int -&gt; a)

type State = { count :: Int }

-- 我们的query类型显示在我们的 `Component` 类型中
counter :: forall input output m. H.Component Query input output m
counter =
  H.mkComponent
    { initialState: \_ -&gt; { count: 0 }
    , render
    , eval: H.mkEval $ H.defaultEval { handleQuery = handleQuery }
    }
  where
  render { count } =
    HH.div_
      [ HH.text $ show count ]

  -- 我们编写了一个函数来处理出现的查询
  handleQuery :: forall action a. Query a -&gt; H.HalogenM State action () output m (Maybe a)
  handleQuery = case _ of
    -- 当我们收到 `Increment` 查询时，我们将增加我们的状态
    Increment a -&gt; do
      H.modify_ \state -&gt; state { count = state.count + 1 }
      pure (Just a)

    -- 当我们收到 `GetCount` 查询时，我们将用`state`进行答复。
    GetCount reply -&gt; do
      { count } &lt;- H.get
      pure (Just (reply count))
</code></pre><p>在这个例子中，我们定义了一个计数器，让父组件来<code class="language-plaintext highlighter-rouge">tell</code>它增加或请求它的当前计数。为此，我们:</p><ul><li>实现了一个查询类型，包括一个<code class="language-plaintext highlighter-rouge">tell</code>风格的查询，<code class="language-plaintext highlighter-rouge">Increment a</code>，和一个<code class="language-plaintext highlighter-rouge">request</code>风格的查询，<code class="language-plaintext highlighter-rouge">GetCount (Int -&gt; a)</code>。我们将此查询类型添加到组件的公共接口<code class="language-plaintext highlighter-rouge">Component</code>中。<li>实现了一个查询处理程序<code class="language-plaintext highlighter-rouge">handleQuery</code>，它在这些查询出现时运行代码。我们将把它添加到我们的<code class="language-plaintext highlighter-rouge">eval</code>中。</ul><p>我们现在知道如何定义<code class="language-plaintext highlighter-rouge">queries</code>并在子组件中评估它们。现在，让我们看看如何从父组件向子组件发送<code class="language-plaintext highlighter-rouge">query</code>。像往常一样，我们可以从定义父组件的<code class="language-plaintext highlighter-rouge">slot</code>类型开始:</p><pre><code class="language-purescript">module Parent where

type Slots = ( counter :: H.Slot Counter.Query Void Int )

_counter = Proxy :: Proxy "counter"
</code></pre><p>我们的<code class="language-plaintext highlighter-rouge">slot</code>类型使用其<code class="language-plaintext highlighter-rouge">query</code>类型记录了<code class="language-plaintext highlighter-rouge">counter</code>组件，并将其<code class="language-plaintext highlighter-rouge">output</code>消息类型保留为<code class="language-plaintext highlighter-rouge">Void</code>，以表示没有。</p><p>当我们的父组件初始化时，我们将从子组件获取计数，然后<code class="language-plaintext highlighter-rouge">increment</code>它，然后再次获取计数，以便我们可以看到它增加了。为此，我们需要在初始化时运行一个<code class="language-plaintext highlighter-rouge">action</code>:</p><pre><code class="language-purescript">data Action = Initialize
</code></pre><p>现在，我们可以继续我们的组件定义:</p><pre><code class="language-purescript">parent :: forall query input output m. H.Component query input output m
parent =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , initialize = Just Initialize
        }
    }
  where
  render :: forall state. state -&gt; H.ComponentHTML Action Slots m
  render _ =
    HH.div_
      [ HH.slot_ _counter unit counter unit ]

  handleAction :: forall state. Action -&gt; H.HalogenM state Action Slots output m Unit
  handleAction = case _ of
    Initialize -&gt;
      -- startCount :: Maybe Int
      startCount &lt;- H.request _counter unit Counter.GetCount
      -- _ :: Maybe Unit
      H.tell _counter unit Counter.Increment
      -- endCount :: Maybe Int
      endCount &lt;- H.request _counter unit Counter.GetCount

      when (startCount /= endCount) do
        -- ... do something
</code></pre><p>这里有几件事情需要注意。</p><ul><li>我们在<code class="language-plaintext highlighter-rouge">slot</code>类型中使用了计数器标签的代理，<code class="language-plaintext highlighter-rouge">_counter</code>，连同它的标识符，<code class="language-plaintext highlighter-rouge">unit</code>，既可以使用<code class="language-plaintext highlighter-rouge">slot</code>函数渲染组件，也可以使用<code class="language-plaintext highlighter-rouge">tell</code>和<code class="language-plaintext highlighter-rouge">request</code>函数向组件发送查询。标签和标识符始终用于处理特定的子组件。<li>我们使用<code class="language-plaintext highlighter-rouge">H.tell</code>函数发送<code class="language-plaintext highlighter-rouge">tell</code>风格的查询<code class="language-plaintext highlighter-rouge">Increment</code>，使用<code class="language-plaintext highlighter-rouge">H.request</code>函数发送<code class="language-plaintext highlighter-rouge">request</code>风格的查询<code class="language-plaintext highlighter-rouge">GetCount</code>。<code class="language-plaintext highlighter-rouge">GetCount</code>查询有一个类型为<code class="language-plaintext highlighter-rouge">(Int -&gt; a)</code>的<code class="language-plaintext highlighter-rouge">reply</code>函数，因此您会注意到，当我们使用它时，我们收到了一个<code class="language-plaintext highlighter-rouge">Maybe Int</code>的响应。</ul><p><code class="language-plaintext highlighter-rouge">tell</code>和<code class="language-plaintext highlighter-rouge">request</code>函数接受一个标签、一个<code class="language-plaintext highlighter-rouge">slot</code>标识符和一个要发送的查询。<code class="language-plaintext highlighter-rouge">tell</code>函数不返回任何东西，但<code class="language-plaintext highlighter-rouge">request</code>函数返回来自<code class="language-plaintext highlighter-rouge">child</code>组件的响应(包裹在<code class="language-plaintext highlighter-rouge">Maybe</code>中)，其中<code class="language-plaintext highlighter-rouge">Nothing</code>表示查询失败(子组件返回<code class="language-plaintext highlighter-rouge">Nothing</code>，或者您提供的标签和<code class="language-plaintext highlighter-rouge">slot</code>标识符中不存在任何组件).还有<code class="language-plaintext highlighter-rouge">tellAll</code>和<code class="language-plaintext highlighter-rouge">requestAll</code>函数向给定标签的所有组件发送相同的查询。</p><p>许多人发现查询是<code class="language-plaintext highlighter-rouge">Halogen</code>库中最令人困惑的部分. 幸运的是，查询的使用率远不如我们在本指南中了解的其他<code class="language-plaintext highlighter-rouge">Halogen</code>功能，如果您遇到困难，您可以随时参考指南的这一部分。</p><h5 id="组件插槽">组件插槽 <a href="#组件插槽" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>我们已经学到了很多关于组件如何相互通信的知识。在我们继续我们的最后一个例子之前，让我们回顾一下我们在此过程中学到的关于<code class="language-plaintext highlighter-rouge">slots</code>的知识。</p><p>一个组件需要知道它支持什么类型的子组件，以便它能够与它们通信。它需要知道它可以向子组件发送哪些查询以及它可以从子组件那里接收哪些<code class="language-plaintext highlighter-rouge">output</code>消息。它还需要知道如何识别向哪个特定组件发送<code class="language-plaintext highlighter-rouge">query</code>。</p><p><code class="language-plaintext highlighter-rouge">H.Slot</code>类型捕获父组件可以支持的特定类型的子组件的<code class="language-plaintext highlighter-rouge">query</code>、<code class="language-plaintext highlighter-rouge">output</code>和唯一标识符。您可以将许多插槽组合成一个<code class="language-plaintext highlighter-rouge">row</code>插槽，其中每个标签用于特定类型的组件。以下是如何读取几个不同插槽的类型定义的方法:</p><pre><code class="language-purescript">type Slots = ()
</code></pre><p>这意味着该组件不支持子组件。</p><pre><code class="language-purescript">type Slots = ( button :: forall query. H.Slot query Void Unit )
</code></pre><p>这意味着组件支持一种类型的子组件，由符号<code class="language-plaintext highlighter-rouge">button</code>标识。您不能向它发送查询(因为<code class="language-plaintext highlighter-rouge">q</code>是一个开放类型变量)并且它不会发出任何<code class="language-plaintext highlighter-rouge">output</code>消息(通常用<code class="language-plaintext highlighter-rouge">Void</code>表示，因此您可以使用<code class="language-plaintext highlighter-rouge">absurd</code>作为处理程序). 您最多可以拥有该组件中的一个，因为只有一个值<code class="language-plaintext highlighter-rouge">unit</code>位于<code class="language-plaintext highlighter-rouge">Unit</code>类型中。</p><pre><code class="language-purescript">type Slots = ( button :: forall query. H.Slot query Button.Output Int )
</code></pre><p>这种类型与前一种非常相似。不同之处在于子组件可以引发<code class="language-plaintext highlighter-rouge">Button.Output</code>类型的<code class="language-plaintext highlighter-rouge">output</code>消息，并且您可以拥有与整数一样多的此组件。</p><pre><code class="language-purescript">type Slots =
  ( button :: H.Slot Button.Query Void Int
  , modal :: H.Slot Modal.Query Modal.Output Unit
  )
</code></pre><p>这种<code class="language-plaintext highlighter-rouge">slot</code>类型意味着组件支持两种类型的子组件，由标签<code class="language-plaintext highlighter-rouge">button</code>和<code class="language-plaintext highlighter-rouge">modal</code>标识。您可以将<code class="language-plaintext highlighter-rouge">Button.Query</code>类型的<code class="language-plaintext highlighter-rouge">query</code>发送到<code class="language-plaintext highlighter-rouge">button</code>组件，并且您不会从它收到任何<code class="language-plaintext highlighter-rouge">output</code>消息. 您可以向<code class="language-plaintext highlighter-rouge">modal</code>组件发送类型为<code class="language-plaintext highlighter-rouge">Modal.Query</code>的<code class="language-plaintext highlighter-rouge">query</code>并从<code class="language-plaintext highlighter-rouge">modal</code>组件接收类型为<code class="language-plaintext highlighter-rouge">Modal.Output</code>的消息。您可以拥有与整数一样多的<code class="language-plaintext highlighter-rouge">button</code>组件，但最多只有一个<code class="language-plaintext highlighter-rouge">modal</code>组件。</p><p><code class="language-plaintext highlighter-rouge">Halogen</code>应用程序中的一个常见模式是组件导出自己的<code class="language-plaintext highlighter-rouge">slot</code>类型，因为它已经知道其<code class="language-plaintext highlighter-rouge">query</code>和消息类型，而不导出标识此特定组件的类型，因为这是父组件的责任。</p><p>例如，如果<code class="language-plaintext highlighter-rouge">button</code>和<code class="language-plaintext highlighter-rouge">modal</code>组件模块导出自己的<code class="language-plaintext highlighter-rouge">slot</code>类型，如下所示:</p><pre><code class="language-purescript">module Button where

type Slot id = H.Slot Query Void id

module Modal where

type Slot id = H.Slot Query Output id
</code></pre><p>那么我们最后一个<code class="language-plaintext highlighter-rouge">slot</code>类型示例将变成这个更简单的类型:</p><pre><code class="language-purescript">type Slots =
  ( button :: Button.Slot Int
  , modal :: Modal.Slot Unit
  )
</code></pre><p>这样做的优点是更简洁，更容易随着时间的推移保持最新状态，就好像<code class="language-plaintext highlighter-rouge">slot</code>类型发生更改一样，它们可能发生在源模块中，而不是在使用<code class="language-plaintext highlighter-rouge">slot</code>类型的任何地方。</p><h5 id="完整示例">完整示例 <a href="#完整示例" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>最后，我们使用本章中讨论的所有通信机制编写了一个父组件和子组件的示例。该示例注释了我们如何解释最重要的代码行 —— 我们通过浏览我们自己的代码库中的这些组件定义而收集到的内容。</p><p>像往常一样，我们建议将此代码粘贴到<a href="https://try.purescript.org/">Try PureScript</a>中，以便您可以交互地探索它。</p><pre><code class="language-purescript">module Main where

import Prelude

import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (logShow)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.VDom.Driver (runUI)
import Type.Proxy (Proxy(..))

main :: Effect Unit
main = HA.runHalogenAff do
  body &lt;- HA.awaitBody
  runUI parent unit body

-- 父组件支持一种类型的子组件，它使用 `ButtonSlot` 插槽类型。 您可以拥有与整数一样多的此类子组件。
type Slots = ( button :: ButtonSlot Int )

-- 父组件只能评估一个动作: 处理来自`button`组件的`output`消息，类型为"ButtonOutput".
data ParentAction = HandleButton ButtonOutput

-- 父组件在本地状态中保持其所有子组件按钮被点击的次数。
type ParentState = { clicked :: Int }

-- 父组件不使用自己的查询、输入或输出类型。它可以使用任何 monad，只要该 monad 可以运行 `Effect` 函数。
parent :: forall query input output m. MonadEffect m =&gt; H.Component query input output m
parent =
  H.mkComponent
    { initialState
    , render
      -- 该组件可以处理的唯一内部事件是在 `ParentAction` 类型中定义的操作。
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  initialState :: input -&gt; ParentState
  initialState _ = { clicked: 0 }

  -- 我们渲染了三个按钮，使用`HandleButton`操作处理它们的`output`消息。 
  -- 当我们的状态改变时，这个渲染函数将再次运行，每次发送新的input(包含一个新标签供子按钮组件使用.)
  render :: ParentState -&gt; H.ComponentHTML ParentAction Slots m
  render { clicked } = do
    let clicks = show clicked
    HH.div_
      [ -- 我们用插槽id 0 渲染我们的第1个按钮
        HH.slot _button 0 button { label: clicks &lt;&gt; " Enabled" } HandleButton
        -- 我们用插槽id 1 渲染我们的第2个按钮
      , HH.slot _button 1 button { label: clicks &lt;&gt; " Power" } HandleButton
        -- 我们用插槽id 2 渲染我们的第3个按钮
      , HH.slot _button 2 button { label: clicks &lt;&gt; " Switch" } HandleButton
      ]

  handleAction :: ParentAction -&gt; H.HalogenM ParentState ParentAction Slots output m Unit
  handleAction = case _ of
    -- 我们处理一个动作，`HandleButton`，它自己处理我们按钮组件的`output`消息。
    HandleButton output -&gt; case output of
      --只有一个`output`消息，`Clicked`。
      Clicked -&gt; do
        -- 当 `Clicked` 消息出现时，我们将增加 state 中的点击计数，然后向第一个按钮发送一个查询，并告诉它为 `true`，
        -- 然后向 所有请求其当前启用状态的子组件 发送一个查询，我们记录日志到控制台。
        H.modify_ \state -&gt; state { clicked = state.clicked + 1 }
        H.tell _button 0 (SetEnabled true)
        on &lt;- H.requestAll _button GetEnabled
        logShow on

-- 我们现在转到子组件，一个名为`button`的组件。

-- 该组件可以接受`ButtonQuery`类型的查询并发送`ButtonOutput`类型的`output`消息。
-- 导出此插槽类型，以便其他组件在构建其插槽`row`时可以使用它。
type ButtonSlot = H.Slot ButtonQuery ButtonOutput

-- We think our button will have the label "button" in the row where it's used,
-- so we're exporting a symbol proxy for convenience.
-- 我们认为我们的按钮将在使用它的`row`中带有标签`button`，因此为方便起见，我们导出了一个符号代理。
_button = Proxy :: Proxy "button"

-- 该组件接受两个查询。第一个是`request`风格的查询，它让父组件从我们这里请求一个`Boolean` 值。
-- 第二个是`tell`风格的查询，它让父组件向我们发送一个`Boolean`值。
data ButtonQuery a
  = GetEnabled (Boolean -&gt; a)
  | SetEnabled Boolean a

-- 这个组件可以通知父组件一个事件，`Clicked`
data ButtonOutput
  = Clicked

-- 该组件可以处理两个内部操作。它可以评估`Click`操作，并且可以在其父组件重新渲染时接收新`input`。
data ButtonAction
  = Click
  | Receive ButtonInput

-- 这个组件接收一个标签作为输入
type ButtonInput = { label :: String }

-- 该组件在状态中存储标签和启用标志
type ButtonState = { label :: String, enabled :: Boolean }

-- 该组件支持`ButtonQuery`类型的查询，需要`ButtonInput`类型的输入，并且可以发送`ButtonOutput`类型的`output`。
-- 它不执行任何`effects`，我们可以看出这是因为`m`类型参数没有约束。
button :: forall m. H.Component ButtonQuery ButtonInput ButtonOutput m
button =
  H.mkComponent
    { initialState
    , render
      -- 该组件可以处理内部操作，处理父组件发送的`query`，并在收到新`input`时进行更新。
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , handleQuery = handleQuery
        , receive = Just &lt;&lt;&lt; Receive
        }
    }
  where
  initialState :: ButtonInput -&gt; ButtonState
  initialState { label } = { label, enabled: false }

  -- This component has no child components. When the rendered button is clicked
  -- we will evaluate the `Click` action.
  -- 该组件没有子组件。点击已渲染的按钮时，我们将评估`Click`操作。
  render :: ButtonState -&gt; H.ComponentHTML ButtonAction () m
  render { label, enabled } =
    HH.button
      [ HE.onClick \_ -&gt; Click ]
      [ HH.text $ label &lt;&gt; " (" &lt;&gt; (if enabled then "on" else "off") &lt;&gt; ")" ]

  handleAction
    :: ButtonAction
    -&gt; H.HalogenM ButtonState ButtonAction () ButtonOutput m Unit
  handleAction = case _ of
    -- 当我们收到新的`input`时，我们会更新状态中的`label`字段。
    Receive input -&gt;
      H.modify_ _ { label = input.label }

    -- 当按钮被点击时，我们更新我们的`enabled`字段，并通知我们的父组件发生了 `Clicked` 事件。
    Click -&gt; do
      H.modify_ \state -&gt; state { enabled = not state.enabled }
      H.raise Clicked

  handleQuery
    :: forall a
     . ButtonQuery a
    -&gt; H.HalogenM ButtonState ButtonAction () ButtonOutput m (Maybe a)
  handleQuery = case _ of
    -- 当我们收到带有布尔值的`tell`风格的`SetEnabled`查询时，我们在state中设置该值。
    SetEnabled value next -&gt; do
      H.modify_ _ { enabled = value }
      pure (Just next)

    -- 当我们收到一个`request`风格的`GetEnabled`查询时，它需要一个布尔结果，我们从我们的状态中获取一个布尔值并用它来回复。
    GetEnabled reply -&gt; do
      enabled &lt;- H.gets _.enabled
      pure (Just (reply enabled))
</code></pre><p>在下一章中，我们将了解有关运行<code class="language-plaintext highlighter-rouge">Halogen</code>应用程序的更多信息。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%89%8D%E7%AB%AF-purescript-halogen/'>前端 purescript halogen</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%89%8D%E7%AB%AF-purescript-halogen/" class="post-tag no-text-decoration" >前端 purescript halogen</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Halogen-06-父子组件 - Lovelace&amp;url=/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Halogen-06-父子组件 - Lovelace&amp;u=/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/&amp;text=Halogen-06-父子组件 - Lovelace" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF-purescript-halogen/">前端 purescript halogen</a> <a class="post-tag" href="/tags/eutxo%E6%A8%A1%E5%9E%8B/">eUTxO模型</a> <a class="post-tag" href="/tags/utxo%E6%A8%A1%E5%9E%8B/">UTxO模型</a> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB%E8%B4%A6/">分类账</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Halogen-01-%E6%8C%87%E5%8D%97/"><div class="card-body"> <em class="timeago small" date="2022-01-02T11:04:00+08:00" >Jan 2, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Halogen-01-指南</h3><div class="text-muted small"><p> Halogen指南 Halogen是一个声明式的、基于组件的用于PureScript的UI库，它强调类型安全。在本指南中，您将学习在Halogen中编写实际应用程序所需的核心思想和模式。 这是一个微型Halogen应用程序，可让您递增和递减计数器: module Main where import Prelude import Effect (Effect) import Halo...</p></div></div></a></div><div class="card"> <a href="/posts/Halogen-02-%E6%B8%B2%E6%9F%93HalogenHTML/"><div class="card-body"> <em class="timeago small" date="2022-01-02T11:04:00+08:00" >Jan 2, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Halogen-02-渲染HalogenHTML</h3><div class="text-muted small"><p> 渲染Halogen HTML Halogen HTML元素是Halogen应用程序的最小构建块。这些元素描述了您希望在屏幕上看到的内容。 Halogen HTML元素不是组件（我们将在下一章中介绍组件），如果没有组件，元素就无法呈现。但是，编写生成Halogen HTML的辅助函数然后在组件中使用这些函数是很常见的。 在本章中，我们将探索在没有组件或事件的情况下编写HTML。 Halo...</p></div></div></a></div><div class="card"> <a href="/posts/Halogen-03-%E7%BB%84%E4%BB%B6/"><div class="card-body"> <em class="timeago small" date="2022-01-02T11:04:00+08:00" >Jan 2, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Halogen-03-组件</h3><div class="text-muted small"><p> 组件介绍 Halogen HTML是Halogen应用程序的基本构建块之一。但是，生成HTML的纯函数缺少实际应用程序所需的许多基本功能: 表示随时间变化的值的状态、对网络请求等事物的effects以及响应DOM事件的能力(例如，当用户单击按钮时). Halogen组件接受input并生成Halogen HTML, 就像我们目前看到的函数一样。然而, 与函数不同的是，组件维护内部状态，可...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Halogen-05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A2%E9%98%85/" class="btn btn-outline-primary" prompt="Older"><p>Halogen-05-生命周期和订阅</p></a> <a href="/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="btn btn-outline-primary" prompt="Newer"><p>Halogen-07-运行应用程序</p></a></div><script src="https://utteranc.es/client.js" repo="haskell-monad/haskell-monad.github.io" issue-term="title" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/haskell-monad">luna</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AF-purescript-halogen/">前端 purescript halogen</a> <a class="post-tag" href="/tags/eutxo%E6%A8%A1%E5%9E%8B/">eUTxO模型</a> <a class="post-tag" href="/tags/utxo%E6%A8%A1%E5%9E%8B/">UTxO模型</a> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB%E8%B4%A6/">分类账</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-YJYEMD99ZB"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-YJYEMD99ZB'); }); </script>
