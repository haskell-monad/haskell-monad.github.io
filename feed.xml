<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Lovelace</title><subtitle>cardano, blockchain, dapp, haskell-monad's blog</subtitle> <updated>2023-01-18T15:35:33+08:00</updated> <author> <name>luna</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2023 luna </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>扩展的UTxO模型</title><link href="/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/" rel="alternate" type="text/html" title="扩展的UTxO模型" /><published>2022-03-29T09:12:00+08:00</published> <updated>2022-03-29T09:12:00+08:00</updated> <id>/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/</id> <content src="/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/" /> <author> <name>{"name"=>"Cardano", "link"=>"https://www.notion.so/Extended-UTXO-7cc52460f0bd4a0f8a7a3097330f830b"}</name> </author> <category term="Cardano" /> <summary> 序言 区块链是状态机 —— 它们跟踪状态(例如，每个钱包持有多少比特币)和状态随时间的变化。 每笔交易(因此每一个区块)都会改变区块链的状态。在区块链中跟踪和管理状态的两种最流行的方法是: 未使用的交易输出(UTxO)模型和Account(账户)模型。 UTxO模型是由比特币开创的，可以直观地认为是类似现金的(下面将进一步详述)，而账户模型是由以太坊推广的，可以直观地认为是类似银行账户的。与所有工程和设计决策一样，UTxO和账户模型需要权衡取舍。 例如，账户模型比UTxO模型具有更多的表达能力，但具有更差的确定性(当底层区块链使用账户模型时，交易更有可能失败)。 支持Cardano项目的科学和研究机构IOHK的团队已经创新了一种新的状态管理系统，他们称之为扩展的UTxO模型(eUTxO)。eUTxO模型是UTxO模型和账户模型的综合，它结合了账户模型的表达能力和UTxO模型的... </summary> </entry> <entry><title>Halogen-07-运行应用程序</title><link href="/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" rel="alternate" type="text/html" title="Halogen-07-运行应用程序" /><published>2022-01-02T11:04:00+08:00</published> <updated>2022-01-02T11:04:00+08:00</updated> <id>/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id> <content src="/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" /> <author> <name>{"name"=>"purescript-halogen", "link"=>"https://github.com/purescript-halogen/purescript-halogen/blob/master/docs/guide/06-Running-Application.md"}</name> </author> <category term="前端 purescript halogen" /> <summary> 运行应用程序 在本指南的过程中，我们已经多次看到运行Halogen应用程序的标准方法。在本章中，我们将了解运行Halogen应用程序时实际发生的情况以及如何从外部控制正在运行的应用程序。 使用runUI和awaitBody PureScript应用程序使用它们Main模块中的main函数作为它们的入口点。这是Halogen应用程序的标准main函数: module Main where import Prelude import Effect (Effect) import Halogen.Aff as HA import Halogen.VDom.Driver (runUI) main :: Effect Unit main = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit bo... </summary> </entry> <entry><title>Halogen-06-父子组件</title><link href="/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/" rel="alternate" type="text/html" title="Halogen-06-父子组件" /><published>2022-01-02T11:04:00+08:00</published> <updated>2022-01-02T11:04:00+08:00</updated> <id>/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/</id> <content src="/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/" /> <author> <name>{"name"=>"purescript-halogen", "link"=>"https://github.com/purescript-halogen/purescript-halogen/blob/master/docs/guide/05-Parent-Child-Components.md"}</name> </author> <category term="前端 purescript halogen" /> <summary> 父子组件 Halogen是一个没有偏见的UI库：它允许您创建声明式用户界面，而无需强制执行特定架构。 迄今为止，我们的应用程序由单个Halogen组件组成。您可以将大型应用程序构建为单个组件，并随着应用程序的增长将state、handleAction 和render函数分解为单独的模块。这让您可以在Halogen中使用Elm架构。 但是，Halogen支持具有任意深度组件树的架构。这意味着您编写的任何组件都可以包含更多组件，每个组件都有自己的状态和行为. 大多数Halogen应用程序都以这种方式使用组件架构，包括Real World Halogen应用程序。 当您从单个组件移动到多个组件时，您开始需要机制，以便组件可以相互通信。Halogen为我们提供了父子组件通信的三种方式: 父组件可以向子组件发送查询，要么告诉子组件做某事，要么从子组件请求一些信息。 父组件为子... </summary> </entry> <entry><title>Halogen-05-生命周期和订阅</title><link href="/posts/Halogen-05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A2%E9%98%85/" rel="alternate" type="text/html" title="Halogen-05-生命周期和订阅" /><published>2022-01-02T11:04:00+08:00</published> <updated>2022-01-02T11:04:00+08:00</updated> <id>/posts/Halogen-05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A2%E9%98%85/</id> <content src="/posts/Halogen-05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A2%E9%98%85/" /> <author> <name>{"name"=>"purescript-halogen", "link"=>"https://github.com/purescript-halogen/purescript-halogen/blob/master/docs/guide/04-Lifecycles-Subscriptions.md"}</name> </author> <category term="前端 purescript halogen" /> <summary> 生命周期和订阅 到目前为止，您学到的概念涵盖了您将编写的大多数Halogen组件。大多数组件都有内部状态，呈现HTML元素，并通过在用户单击、悬停或以其他方式与呈现的HTML交互时执行操作来做出响应。 但是actions也可以从其他类型的事件内部产生。下面是一些常见的例子: 您需要在组件启动时运行一个action(例如，您需要执行一个effect来获得您的初始状态)或者当组件从DOM中移除时(例如，清理您获得的资源)。这些被称为生命周期事件。 您需要定期运行action(例如，您需要每10秒执行一次更新),或者当一个事件发生在你渲染的HTML之外时(例如，你需要在DOM窗口上按下一个键时运行一个action, 或者您需要处理在第三方组件(如文本编辑器)中发生的事件)。这些由订阅处理。 当我们在下一章学习父组件和子组件时，我们将学习在组件中产生action的另一种方... </summary> </entry> <entry><title>Halogen-04-执行Effects</title><link href="/posts/Halogen-04-%E6%89%A7%E8%A1%8CEffects/" rel="alternate" type="text/html" title="Halogen-04-执行Effects" /><published>2022-01-02T11:04:00+08:00</published> <updated>2022-01-02T11:04:00+08:00</updated> <id>/posts/Halogen-04-%E6%89%A7%E8%A1%8CEffects/</id> <content src="/posts/Halogen-04-%E6%89%A7%E8%A1%8CEffects/" /> <author> <name>{"name"=>"purescript-halogen", "link"=>"https://github.com/purescript-halogen/purescript-halogen/blob/master/docs/guide/03-Performing-Effects.md"}</name> </author> <category term="前端 purescript halogen" /> <summary> Performing Effects 到目前为止，我们已经涵盖了很多领域。您知道如何编写Halogen HTML。您可以定义响应用户交互的组件并按类型对组件的每个部分进行建模, 有了这个基础，我们就可以在编写应用程序时继续使用另一个重要的工具: 执行effects。 在本章中，我们将通过两个示例探索如何在您的组件中执行effects: 生成随机数并发出HTTP请求。一旦您知道如何执行effects，您就可以很好地掌握Halogen基础知识. 在我们开始之前，重要的是要知道您只能在评估期间执行effects，例如像handleAction这样使用HalogenM类型的函数. 但是您无法在生成初始状态或渲染期间执行effects。由于您只能在HalogenM中执行effects，因此在深入研究示例之前，让我们简要了解一下它的更多信息。 HalogenM类型 如果您还记得上一章的... </summary> </entry> </feed>
