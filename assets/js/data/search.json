[ { "title": "扩展的UTxO模型", "url": "/posts/%E6%89%A9%E5%B1%95%E7%9A%84utxo%E6%A8%A1%E5%9E%8B/", "categories": "Cardano", "tags": "UTxO模型, eUTxO模型, 分类账", "date": "2022-03-29 09:12:00 +0800", "snippet": "序言区块链是状态机 —— 它们跟踪状态(例如，每个钱包持有多少比特币)和状态随时间的变化。每笔交易(因此每一个区块)都会改变区块链的状态。在区块链中跟踪和管理状态的两种最流行的方法是: 未使用的交易输出(UTxO)模型和Account(账户)模型。UTxO模型是由比特币开创的，可以直观地认为是类似现金的(下面将进一步详述)，而账户模型是由以太坊推广的，可以直观地认为是类似银行账户的。与所有工程和设计决策一样，UTxO和账户模型需要权衡取舍。例如，账户模型比UTxO模型具有更多的表达能力，但具有更差的确定性(当底层区块链使用账户模型时，交易更有可能失败)。支持Cardano项目的科学和研究机构IOHK的团队已经创新了一种新的状态管理系统，他们称之为扩展的UTxO模型(eUTxO)。eUTxO模型是UTxO模型和账户模型的综合，它结合了账户模型的表达能力和UTxO模型的隐私性、安全性、并发性和确定性。有很多 文章 比较 比特币的UTxO 模型 和 以太坊的帐户模型 但很少有文章将这种比较扩展到eUTxO模型。本文将快速介绍UTxO和Account模型的基础知识，并尝试彻底解释eUTxO模型。UTxO模型首先，让我们为比特币开创的UTxO模型建立一些直觉。请记住，UTxO代表未使用/未花费的交易输出。让我们从一个基于上述直觉的例子开始，即UTxO模型类似于现金。假设Alice有一张100美元的钞票，她需要付给Bob 3美元。 Alice将她的100美元钞票交给Bob，然后Bob将返还给Alice97美元。在此示例中，Alice以价值100美元的未花费交易输出(UTxO)开始。然后，她在一笔交易中(花费/消费)了该输出(100美元的钞票)，从而产生了2个新的未花费交易输出(UTxOs)，一个为3美元(由Bob拥有)，另一个为97美元(由Alice拥有)。现在请注意，原来的100美元的UTxO不能再次(消费/花费)。每个UTxO只能使用一次，并且可以生成一个或多个新的UTxOs。UTxO模型中的每笔交易都会接收一个UTxOs输入列表，消费它们，并创建一个新的UTxOs列表，这些新的UTxOs可以稍后在新的交易中(使用/花费)。UTxO的另一个值得注意的特性是，交易的输入值必须始终等于输出值(减去区块链为处理交易而收取的任何费用)。UTxO模型具有很好的并发性，因为状态是本地的(与下面描述的Account模型的全局状态相比)。这种本地状态的概念源自这样一个事实: UTxO特定于每个钱包。如果Alice与Charlie进行交易，这不可能影响Bob的交易能力，因为Alice无法消费Bob的UTxOs。账户模型中并非如此，我们将在下一节中详细说明。因为Alice和Bob进行的交易之间没有任何依赖关系，所以他们的交易可以更有效地并行化。有人认为UTxO模型具有更好的隐私属性，但我还不相信。据称，UTxO模型具有更好的隐私性，因为用户可以为每笔交易使用新钱包，并在收到他们发起的交易的零钱时(即: Alice在上面的示例中获得了97美元的零钱)。虽然Account模型没有change(找零)的概念，但用户也可以选择为Account模型中的每笔交易创建一个新钱包。在为每笔交易创建新钱包时，UTxO模型的一个好处是，分布在多个钱包中的价值可以比在账户模型中更容易地(整合/合并)。UTxO模型中的整合理论上可以在单个交易中完成，因为可以一次消耗所有UTxO并创建单个输出(但是块大小的实际限制将限制这一点，例如，一次最多消耗6个UTxO)。UTxO模型的一个缺点是交易的大小。在UTxO模型中，每笔交易都指定一个输入列表和一个输出列表。这意味着一些有很多输入和输出的交易可能会变得非常大。帐户模型中的交易较小，这将在下文更详细地描述。另一个很大的缺点是模型的概念困难 - 大多数人比UTxO模型更容易理解和概念化帐户模型，这意味着用户和开发人员都有更大的错误空间。UTxO模型的最后一个问题是它的智能合约能力有限。比特币对多重签名、时间锁定交易和P2SH等智能合约的支持有限。但是，比特币UTxO模型不支持图灵完备的脚本。Account模型与UTxO模型相比，账户模型可以直观地被认为类似于银行账户。账户模型中的交易指定debits(借方)和credits(贷方)，而不是消费和创建UTxO。让我们再次假设Alice有100美元并想向Bob发送3美元，尽管这次钱不是现金形式，而是存在银行账户中。为了让Alice将这笔钱汇给Bob，她要求她的银行从她的账户中debit(借记)3美元，并在Bob的账户中credit(贷记)3美元。请注意这里没有change(找零)的概念，以及银行如何管理这些credits(贷方)和debits(借方)。我们在上面提到了UTxO模型对于大多数用户来说是如何不那么直观的，希望这个例子能说明为什么会这样。从概念上来说，用”未花费的交易输出”来思考是很困难的，但从贷方和借方的角度来看却很容易。我们还提到了当有很多的输入和输出时，UTxO模型中的交易如何变得非常大。账户模型中的交易更简单、更小，因为每笔交易都指定了一个简单的贷记/借记方案 —— “向Bob发送 x ETH“。与UTxO模型相比，账户模型更具表现力。账户模型支持区块链上的long lived(长期)合约，可以为生态系统中的每个账户保留自己的状态。UTxO模型支持长期合约，但UTxO模型的原语不允许图灵完备的表达能力。例如，Alice可以在账户模型区块链上编写智能合约，该合约发行代币并充当银行跟踪持有代币的每个钱包，并在代币持有人使用代币进行交易时执行借记和贷记。智能合约充当银行管理和调解交易的想法极大影响了账户模型的并发属性。由于存在中央中介(充当银行的智能合约)的概念，Alice与Charlie进行的交易可能会影响到Bob的交易能力。作为一个人为的例子，智能合约可能有一个条款，如果所有账户余额小于10，则阻止任何人进行交易。假设Alice的余额为11，Bob的余额为5。还假设Alice和Bob都想向Charlie发送2个硬币。如果Alice的交易首先执行，Bob的交易将失败，因为Alice的余额为9，Bob的余额为5，Charlie的余额为2，这种分配违反了智能合约的”所有余额必须为10或更多”的条件。但是，如果Bob的交易先执行，它会成功，因为Alice将拥有超过10个硬币(当前还是11)。Bob的第一笔交易成功不会影响Alice的交易能力，因为仍然会有一个人(Alice)的余额大于10。这展示了Alice的交易如何影响Bob的交易能力(与UTxO模型相反)，这意味着账户模型中的交易不能像UTxO模型那样有效地并行化。账户模型中的交易顺序远比UTxO模型重要。账户模型的另一个后果是它使多代币交易比eUTxO模型更困难(我们将在下一节中详细说明)。如果Alice有10个AliceCoin和10个BobCoin，并且想将每个硬币中的5个发送给Bob，她通常会通过2次单独的交易来做到这一点，一笔交易发送5AliceCoin，另一笔交易发送5BobCoin。发生这种情况是因为AliceCoin和BobCoin都由独立的智能合约管理，并且它们都彼此独立地管理代币余额。必须独立联系每个合约以执行适当的借贷，通常在两个单独的交易中.但是，可以在账户模型中编写第三个智能合约，该合约在执行时会向AliceCoin和BobCoin智能合约发出正确的请求。Alice理论上可以与AliceAndBobCoinWrapper合约进行交互，该合约将执行对AliceCoin和BobCoin合约的适当调用，但这种范例有几个缺点，例如安全性(Alice必须授予AliceAndBobCoinWrapper合约与她的代币交互的权限)、费用(可能这种情况下，使用包装合同比向各自的智能合同发出两个独立的交易更昂贵)、确定性(当合约变得更复杂时更有可能发生故障)和全面性(如果Alice有第三或第四个想要发送的硬币怎么办?)。eUTxO模型扩展的UTxO模型旨在将账户模型中的智能合约的表现力与UTxO模型的确定性和可并行性结合起来。eUTxO模型具有与UTxO模型相同的类似现金的直觉，但在构建交易时可以更好地控制如何消耗输入。可以在Cardano开发人员文档中找到eUTxO模型的快速摘要，并且可以在IOHK博客上找到介绍该想法及其形式属性的完整科学论文。除了这两个，IOHK在他们的博客上发表了一篇论文，将eUTxO模型与账户模型进行了比较，但这篇论文在数学上非常密集。IOHK教育总监Lars Brujnes的这段视频很好地概述了UTxO模型、账户模型和eUTxO模型。它是如何工作的让我们首先回顾一下UTxO模型的一些更深层的机制。每个UTxO都有3个字段: 一个表示UTxO的”大小”的value、一个帐户的公钥(已授权可以花费该utxo)和一个验证器函数v，它接受一个我们称为redeemer的参数p。当一个交易试图消费一个UTxO时，它必须提供一个redeemer，使得v(value, p)=true。通常，此redeemer是由钱包私钥签名的交易的哈希值。验证者将(大约)检查交易是否由与UTxO中的公钥对应的私钥签署，确保UTxO只能由授权钱包使用。可以使用更复杂的validators(验证器)和redeemers，但它们仍然无法提供完整的智能合约功能。使用这种轻量级模型可以执行的脚本类型是有限的。eUTxO模型通过几个关键机制扩展了这个模型: 每个UTxO都会有一个称为datum的额外字段d，它可以持有任意数据(用于跟踪一系列交易中的嵌入状态) 除了redeemer之外，每笔交易tx的完整信息都会传递给验证者(用于称为合约连续性的概念) validator(验证器)可以有任意逻辑在eUTxO模型中，为了消耗UTxO，必须满足v(value, p, d, tx)=true。这意味着UTxO的validator(验证器)必须批准交易tx可以消费带有redeemer p和datum d的value。请记住，可以将区块链视为状态机。我们可以用同样的方式来思考一系列连续的交易。每笔交易都可以演化出一个嵌入在区块链这个更大的状态机中的状态机。为了使一系列交易连续，它们必须强制执行相同的约束。该datum使一系列连续的交易能够管理它们自己的状态。将完整交易tx传递给validator(验证器)使验证器能够强制交易的输出使用相同的合约代码。示例让我们通过一个示例来说明eUTxO模型如何为datum、validator(验证器)和合约连续性的概念建立更多的直觉。让我们来看看n-of-m多重签名合约。多重签名合约是一个”具有m个授权人但只需要n个授权人进行签署就可以执行合约”的合约.假设Alice和Bob想付钱给Charlie做一些工作。而Charlie想知道Alice和Bob有足够的钱付给他。在Charlie完成之前，Alice和Bob不想支付工作费用。他们三人可以签订2-of-3多重签名合同，该合同将持有用于支付Charlie的资金。这使Charlie能够确认Alice和Bob拥有足够的资金，同时也让Alice和Bob控制资金，直到工作完成。为了进行支付，3人中的任何2人都可以签署合同以释放托管资金。下面是一个状态转换图，取自eUTxO论文，它概述了多重签名合约的行为方式:Holding状态是尚未提出付款的情况。从这个状态，合约可以通过Propose函数转换到Collect 状态。一旦进入Collect状态，就有三种可能的转换: 通过Add函数返回Collect，通过Pay函数返回Holding，通过Cancel函数返回Holding。 Transaction 消费的UTxO Redeemer 产生的UTxO Datum 创建合约     a {} Propose(提议)付钱给Charlie a Propose(100, Charlie, 10) b Collecting((100, Charlie, 10), {}) Charlie签署多签 b Add(sig_charlie) c Collecting((100, Charlie, 10), {sig_charlie}) Alice签署多签 c Add(sig_alice) d Collecting((100, Charlie, 10), {sig_charlie, sig_alice}) Charlie完成付款 d Pay e {} 上面的表格总结了一系列潜在的交易，这些交易使用了上面所示的多签智能合约状态机。下面我将对这些交易进行描述和阐述。当Alice、Bob和Charlie达成协议，例如向Charlie支付100 ADA时，他们可以启动合约，合约将以Holding状态开始(此时datum为空)。Alice、Bob和Charlie的签名被写入到合约代码中，n的值(等于2)也是如此。此合约启动的结果将是一个UTxO，我们将其称为UTxO a，它有一个强制执行有效状态转换的验证器、我们刚刚解释的空的datum以及最终支付给Charlie的值。一旦Charlie认为他已经完成了工作，就可以使用redeemer Propose(100, Charlie, 10)来消费UTxO a，这意味着Charlie提议在时间10之前向自己支付所有100 ADA。这将创建一个新的UTxO，我们称之为b，它有一个值近似Collecting((100, Charlie, 10), {})的datum，这意味着Charlie正试图在时间10之前收集100个ADA，但还没有人提交签名。UTxO b将具有与UTxO相同的验证器(这是合约的连续性)。Charlie现在可以使用redeemer Add(sig_charlie)提交一个消耗UTxO b的新交易。由于Charlie是该合约的授权消费者，这将创建一个新的UTxO c，其datum为Collecting((100, Charlie, 10),{sig_charlie}). 现在datum表明三个签名者中的一个已授权向Charlie发送100 ADA.如果Charlie现在尝试用redeemer Pay来消费UTxO c(因为他很贪婪并且想要他的钱)，那么交易将会失败，因为验证器将看到在需要2个签名时却只存在1个签名。同样，如果Charlie尝试重新添加他的签名以满足2个签名阈值，他只会浪费他的钱，因为合同会确保不会多次添加相同的签名。Charlie也可以在生成UTxO c时尝试更改验证器，但如果他尝试这样做，UTxO b的验证器会看到这一点并拒绝交易(请记住，在消费以前的输出时，整个交易都会传递给验证器，包括输出)。现在，Alice或Bob都可以提交带有他们签名的交易来推进状态图。假设Alice提交了一笔交易，使用redeemer Add(sig_alice)来消费UTxO c。这将创建一个新的UTxO d，其datum为Collecting((100, Charlie, 10), {sig_charlie, sig_alice})。像以前一样，UTxO d将具有与UTxO c相同的验证器。现在，Charlie可以使用redeemer Pay提交消费UTxO d的交易，以完成对自己的付款。之所以会发生这种情况，是因为redeemer Pay的唯一条件是有足够多的授权签名已经签署了合同，在本例子中，Alice和Charlie都已经成功签署了合同。如果付款未在时间10之前完成，那么任何人都可以通过使用redeemer Cancel来提交交易以取消付款。这会将合约转换回具有一个空的redeemer的Holding状态。然后可以再次开始proposal(提议)过程。eUTxO的特性eUTxO模型保留了UTxO模型的许多相同属性，例如可扩展性、确定性、隐私性，同时将脚本功能扩展为图灵完备。eUTxO模型的一个有趣方面是它可能从根本上比帐户模型更具表现力。这在IOHK博客上的论文中说: 尽管translations(翻译/转换)暗示了accounting(会计/账户)等价性，但命题2和Sec的translation(翻译)表明，5.2表明通常需要创建多个基于帐户的交易来模拟单个基于UTXO的交易的效果。这一点很重要: 虽然单个基于UTXO的交易中的所有价值转移都是以原子方式同时处理的，但不能保证相应的基于账户的交易也是如此, 从理论上讲，他们的执行之间可能存在很大的时间差距。这篇论文文不讨论eUTxO模型，但与介绍eUTxO模型的论文相结合时，可以合理地得出结论，eUTxO模型至少与帐户模型一样具有表现力(并且可能更具表现力)。这种表现力的一个例子可以在Cardano上开发的现实世界实用程序中找到。一项名为DripDropz的服务允许生态系统中的参与者从单一界面领取可供他们使用的空投。这在账户模型中是不可能的(我不确定这一点，但我从未见过这样的工具用于基于账户的区块链)。DripDropz能够在一次交易中向3个不同的参与者发送超过10种不同的资产。这意味着多达30个独特的资产(没有两个参与者索取相同的空投)在一次交易中被转移。这在账户模型中基本上是不可能的。有可能构建可以执行类似事情的包装合约，但这些包装合同将受到组合爆炸的影响，以涵盖所有可能的资产索赔组合。eUTxO模型比Account模型更易于静态分析和形式验证。这是因为eUTxO模型中的状态是局部的(即:绑定到每个地址)，而不是全局的。由于帐户模型的全局状态，对帐户模型中给定的智能合约进行形式化分析需要对给定智能合约与之交互的每个合约进行建模。例如, 智能合约a调用智能合约b调用智能合约c在b仍在等待c完成时回调智能合约b的形式化分析将非常困难(特别是如果状态可以在各种智能合约调用之间改变).我在形式分析方面的背景不够深入，无法详细描述为什么这很难分析。但是，请记住，要使任何交易在eUTxO模型中有效，必须满足以下条件: v(value, p, d, tx)=true。验证器是纯函数 —— 它们是幂等的并且没有副作用。尽管datum可以从一个UTxO更改为下一个，但将其视为产生新状态更为合理，因为”旧”UTxO上的datum不能再被消耗。当进行交易时，旧datum实际上被丢弃，并在其位置上创建了一个新datum。纯函数特别适用于形式化和静态分析.我们已经多次讨论过帐户模型中的交易必须如何串行完成(因为存在全局状态，智能合约可以相互交互，改变全局状态)。我们还将其与常规UTxO模型进行了比较，该模型支持更多并行处理，因为不共享相同输入(使用相同UTxO)的交易彼此完全独立。这也适用于eUTxO模型。不消耗相同输入的交易可以并行处理。这为朴素的第1层处理能力提供了显着的性能改进，但也使分片在未来更容易实现。对于绝大多数（也许是全部？）区块链，每个节点和矿工/验证者处理每一笔交易，与分片模式相比，这相对低效和昂贵。分片通过分割区块链的状态，使每个分片负责区块链的一小部分，从而降低节点和矿工/验证器的数据存储和处理需求。由于帐户模型的全局状态，与UTxO模型相比，使用帐户模型进行分片相对更加困难。例如，以太坊有一个相当复杂的分片路线图，该路线图将于2023年发布(但根据之前估计的及时性，该路线图可能会推迟很久)。Cardano目前没有详细的分片路线图，但该项目的Basho阶段(我们目前正在进行)将使用侧链进行分片解决方案。Milkomeda是一个由DcSpark开发的侧链，目前在主网上处于测试阶段。如前所述，UTxO模型不如账户模型直观。这意味着制作智能合约的开发人员可能会在使用eUTxO模型时遇到困难。除了开发人员遇到困难之外，用户在与eUTxO链上的智能合约交互时可能很难概念化他们在做什么。不可否认，这两个事实都会减缓eUTxO模型的采用。但是，由于我们在上面已经表明，eUTxO模型至少与帐户模型一样具有表达能力，因此有一条清晰的帐户模型兼容性路径。事实上，有几个项目正在筹备中，这将使开发人员从帐户模型迁移到eUTxO模型变得更加容易: Milkomeda(EVM侧链)、IELE(将为Mamba提供动力)和Avoum(使开发人员能够直接为eUTxO模型编写基于帐户的智能合约)。一个有益的观察是，曾几何时，在从单核计算到多核计算的过渡期间，编写利用多核的代码很困难，但最终构建了新的工具和抽象，从而显着降低了新的多核范式的复杂性.从基于账户的区块链到基于eUTxO的区块链的过渡(如果发生的话)也是如此 —— 将构建和发现简化开发过程的工具和抽象。结论Extended UTxO模型是IOHK的一项新创新，IOHK是Cardano区块链背后的科学和工程公司。eUTxO模型结合了智能合约在账户模型中的表现力和UTxO模型的可并行性和确定性。IOHK的研究表明，eUTxO模型实际上可能比账户模型更具表现力，这要归功于交易与UTxO的交互方式的独特属性。除此之外，eUTxO模型更容易进行形式化和静态分析，这将为用户提供更高程度的保证，即他们与之交互的合约将按预期运行。尽管eUTxO模型不如帐户模型直观，但目前正在构建工具和抽象，这将有助于弥合差距并简化学习和过渡过程。" }, { "title": "Halogen-07-运行应用程序", "url": "/posts/Halogen-07-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "运行应用程序在本指南的过程中，我们已经多次看到运行Halogen应用程序的标准方法。在本章中，我们将了解运行Halogen应用程序时实际发生的情况以及如何从外部控制正在运行的应用程序。使用runUI和awaitBodyPureScript应用程序使用它们Main模块中的main函数作为它们的入口点。这是Halogen应用程序的标准main函数:module Main whereimport Preludeimport Effect (Effect)import Halogen.Aff as HAimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit body-- 假设您已经为您的应用程序定义了一个根组件component :: forall query input output m. H.Component query input output mcomponent = ...main中使用的最重要的函数是runUI函数。为runUI提供根组件、根组件的input值和对DOM元素的引用，它将向Halogen虚拟DOM提供您的应用程序. 然后，虚拟DOM将在该元素上渲染您的应用程序，并在应用程序运行期间保持它。runUI :: forall query input output . Component query input output Aff -&amp;gt; input -&amp;gt; DOM.HTMLElement -&amp;gt; Aff (HalogenIO query output Aff)如您所见，runUI函数要求您的Halogen应用程序最终可以在Aff monad中运行。在本指南中，我们使用了诸如monadefect和MonadAff之类的约束，这些约束是Aff所满足的，所以我们很清楚。 如果您选择为您的应用程序使用另一个monad，那么您需要在将您的应用程序提供给runUI之前将其提升以在Aff中运行。Real World Halogen使用一个自定义的AppM monad，这是一个很好的例子。除了runUI，我们还使用了另外两个辅助函数。首先，我们使用awaitBody等待页面加载，然后获取对&amp;lt;body&amp;gt;标签的引用作为应用程序控制的根HTML元素。其次，我们使用runHalogenAff从Effect内部启动异步effects(我们的Aff代码包含awaitBody和runUI).这是必要的，因为awaitBody、runUI和我们的应用程序运行在Aff monad中，而PureScript的main函数必须在Effect中。我们在这里使用的main函数是运行Halogen应用程序的标准方式，它是页面上唯一运行的东西。但是，有时您可能会使用Halogen来接管页面的一部分，或者您可能正在运行多个Halogen应用程序。在这些情况下，您可能会用到一对不同的辅助函数: awaitLoad阻塞，直到文档加载完毕，以便您可以安全地检索对页面上HTML元素的引用 selectElement可用于定位页面上的特定元素以将应用程序嵌入其中使用HalogenIO当您使用runUI运行Halogen应用程序时，您会收到HalogenIO类型的函数记录. 这些函数可用于从应用程序外部控制您的根组件。从概念上讲，它们就像您的应用程序的临时父组件。type HalogenIO query output m = { query :: forall a. query a -&amp;gt; m (Maybe a) , messages :: Event output , dispose :: m Unit } query函数类似于支持tell和request的H.query函数。这允许您从应用程序外部向应用程序的根组件发送query. messages事件可用于订阅来自组件的output消息流 —— 它就像我们提供给slot函数的处理程序，除了在这里我们可以执行一些effect而不是评估一个action。 dispose函数可用于停止和清理Halogen应用程序。这将杀死所有分叉的线程，关闭所有订阅，等等。您不能在应用程序的根目录中使用tell和request，但是可以使用mkTell和mkRequest函数(如下例所示)来达到类似的效果。Halogen应用中一个常见的模式是使用一个Route组件作为应用的根，当URL改变时使用HalogenIO中的query函数来触发应用中的路由改变.您可以在Real World HalogenMain.purs文件中看到执行此操作的完整示例。完整示例: 使用HalogenIO控制按钮您可以将此示例粘贴到Try PureScript中，以探索使用HalogenIO来控制应用程序的根组件。module Example.Driver.IO.Main whereimport Preludeimport Data.Maybe (Maybe(..))import Effect (Effect)import Effect.Console (log)import Halogen (liftEffect)import Halogen as Himport Halogen.HTML as HHimport Halogen.Aff as HAimport Halogen.HTML.Events as HEimport Halogen.HTML.Properties as HPimport Halogen.Subscription as HSimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody io &amp;lt;- runUI component unit body _ &amp;lt;- liftEffect $ HS.subscribe io.messages \\(Toggled newState) -&amp;gt; do liftEffect $ log $ &quot;Button was internally toggled to: &quot; &amp;lt;&amp;gt; show newState pure Nothing state0 &amp;lt;- io.query $ H.mkRequest IsOn liftEffect $ log $ &quot;The button state is currently: &quot; &amp;lt;&amp;gt; show state0 void $ io.query $ H.mkTell (SetState true) state1 &amp;lt;- io.query $ H.mkRequest IsOn liftEffect $ log $ &quot;The button state is now: &quot; &amp;lt;&amp;gt; show state1-- Child component implementationtype Slot = H.Slot Query Messagedata Query a = IsOn (Boolean -&amp;gt; a) | SetState Boolean adata Message = Toggled Booleandata Action = Toggletype State = { enabled :: Boolean }component :: forall i m. H.Component Query i Message mcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , handleQuery = handleQuery } }initialState :: forall i. i -&amp;gt; StateinitialState _ = { enabled: false }render :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender state = let label = if state.enabled then &quot;On&quot; else &quot;Off&quot; in HH.button [ HP.title label , HE.onClick \\_ -&amp;gt; Toggle ] [ HH.text label ]handleAction :: forall m. Action -&amp;gt; H.HalogenM State Action () Message m UnithandleAction = case _ of Toggle -&amp;gt; do newState &amp;lt;- H.modify \\st -&amp;gt; st { enabled = not st.enabled } H.raise (Toggled newState.enabled)handleQuery :: forall m a. Query a -&amp;gt; H.HalogenM State Action () Message m (Maybe a)handleQuery = case _ of IsOn k -&amp;gt; do enabled &amp;lt;- H.gets _.enabled pure (Just (k enabled)) SetState enabled a -&amp;gt; do H.modify_ (_ { enabled = enabled }) pure (Just a)下一步本指南展示了Halogen应用的基本构建块。我们了解了Halogen如何提供一种类型安全、声明式的方式来使用称为组件的可重用部分构建复杂的应用程序.我们学习了如何编写生Halogen HTML的函数、如何编写单个组件以及如何在其他组件中渲染组件。我们还学习了组件如何相互通信以及如何运行完整的Halogen应用程序。您现在知道Halogen是如何工作的，但您可能还不太习惯使用该库构建一个真正的应用程序。这是完全正常的！有更多资源可帮助您继续了解Halogen。 要更深入地了解您在本指南中学到的概念，请浏览概念参考。 要以慢节奏、自下而上的方式学习Halogen，请尝试查看Jordan Martinez的Learn Halogen存储库。 要了解如何在Halogen中构建真实世界的应用程序，请查看Real World Halogen手册和示例应用程序。" }, { "title": "Halogen-06-父子组件", "url": "/posts/Halogen-06-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "父子组件Halogen是一个没有偏见的UI库：它允许您创建声明式用户界面，而无需强制执行特定架构。迄今为止，我们的应用程序由单个Halogen组件组成。您可以将大型应用程序构建为单个组件，并随着应用程序的增长将state、handleAction 和render函数分解为单独的模块。这让您可以在Halogen中使用Elm架构。但是，Halogen支持具有任意深度组件树的架构。这意味着您编写的任何组件都可以包含更多组件，每个组件都有自己的状态和行为. 大多数Halogen应用程序都以这种方式使用组件架构，包括Real World Halogen应用程序。当您从单个组件移动到多个组件时，您开始需要机制，以便组件可以相互通信。Halogen为我们提供了父子组件通信的三种方式: 父组件可以向子组件发送查询，要么告诉子组件做某事，要么从子组件请求一些信息。 父组件为子组件提供它需要的input，每次父组件渲染时都会重新发送。 子组件可以向父组件发射output消息，在发生重要事件时通知它。这些类型参数在Component类型中表示，有些还可以在ComponentHTML和HalogenM类型中找到。例如，支持query、input和output消息的组件将具有以下Component类型:component :: forall m. H.Component Query Input Output m您可以将组件与其他组件通信的方式视为其公共接口，而公共接口显示在Component类型中。在本章中，我们将了解: 如何在你的Halogen HTML中render组件 组件通信的三种方式: query、input和output消息 组件槽、slot函数和Slot类型，使这种通信类型安全我们将首先渲染一个没有query或output消息的简单子组件。然后，我们将构建使用这些方式进行通信的组件，最后一个示例展示了同时使用所有这些机制的父组件和子组件.尝试将示例加载到Try PureScript中以探索本章中讨论的每个通信机制！渲染组件我们通过编写返回Halogen HTML元素的函数来开始本指南。这些函数可以被其他函数用来构建更大的HTML元素树。当我们开始使用组件时，我们开始编写render函数。从概念上讲，组件通过此函数生成Halogen HTML并作为其结果，尽管它们还可以维护内部状态和执行effects等。事实上，虽然到目前为止我们在编写render函数时只使用了HTML元素，但我们也可以使用组件，就好像它们是生成HTML的函数一样。这个类比是不完美的，但它可以是一个有用的心理模型，用于理解在编写渲染函数时如何处理组件。当一个组件渲染另一个组件时，它被称为父组件，它渲染的组件被称为子组件。让我们看看如何在我们的render函数中渲染一个组件，而不是像我们目前看到的那样只渲染HTML元素。我们将首先编写一个使用辅助函数来渲染按钮的组件。然后，我们将把这个辅助函数变成它自己的组件，我们将调整父组件来渲染这个新的子组件。首先，我们将编写一个组件，它使用一个辅助函数来渲染一些HTML:module Main whereimport Preludeimport Halogen as Himport Halogen.HTML as HHparent :: forall query input output m. H.Component query input output mparent = H.mkComponent { initialState: identity , render , eval: H.mkEval H.defaultEval } where render :: forall state action. state -&amp;gt; H.ComponentHTML action () m render _ = HH.div_ [ button { label: &quot;Click Me&quot; } ]button :: forall w i. { label :: String } -&amp;gt; HH.HTML w ibutton { label } = HH.button [ ] [ HH.text label ]这应该看起来很熟悉。我们有一个简单的组件来渲染一个div，还有一个辅助函数button，它将一个给定标签渲染为按钮。需要注意的是，我们的parent组件为我们的state和action保留了类型变量，因为它没有内部状态，也没有任何action。现在，让我们将我们的button函数变成一个组件以进行演示(在现实世界的应用程序中，它太小了).type Input = { label :: String }type State = { label :: String }button :: forall query output m. H.Component query Input output mbutton = H.mkComponent { initialState , render , eval: H.mkEval H.defaultEval } where initialState :: Input -&amp;gt; State initialState input = input render :: forall action. State -&amp;gt; H.ComponentHTML action () m render { label } = HH.button [ ] [ HH.text label ]我们采取了几个步骤将我们的button HTML函数转换为button组件: 我们将辅助函数的参数转换为组件的Input类型。父组件负责将此input提供给我们的组件。我们将在下一节中了解有关input的更多信息。 我们将HTML移动到组件的render函数中。render函数只能访问我们组件的State类型，所以在我们的initialState函数中，我们将输入值复制到我们的state中，以便我们可以渲染它。将input复制到state是Halogen中的常见模式。另请注意，我们的render函数未指定action类型(因为我们没有任何action)并使用()指示我们没有子组件。 我们使用defaultEval，未修改，作为我们的EvalSpec，因为这个组件不需要响应内部发生的事件 —— 例如，它没有action，也没有使用生命周期事件。不过，我们的父组件现在坏了！如果您一直在关注，您现在会看到一个错误:[1/1 TypesDoNotUnify] 16 render _ = HH.div_ [ button { label: &quot;Click Me&quot; } ] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not match type Component HTML t2 { label :: String } with type Function不能仅仅通过将组件的input作为函数参数来渲染组件。即使组件生成普通的Halogen HTML，它们也可以与父组件通信；出于这个原因，组件需要额外的信息才能像普通元素一样渲染。从概念上讲，组件在HTML树中占据一个slot。这个插槽是组件可以生成Halogen HTML的地方，直到它从DOM中被移除。插槽中的组件可以被认为是一个动态的、有状态的HTML元素。您可以将这些动态元素与普通Halogen HTML元素自由混合，但动态元素需要更多信息。这些额外的信息来自ComponentHTML中使用的slot函数和Slot类型，到目前为止，我们将它们留作空行, ()。稍后我们将更多地讨论在插槽中渲染组件，但现在让我们开始编译。我们可以通过slot函数在slot中渲染我们的组件来修复我们的render函数。我们还将更新ComponentHTML中的slot类型，以包含我们现在必须支持的Halogen HTML组件。此差异演示了渲染HTML元素和渲染组件之间的差异:+ import Type.Proxy (Proxy(..))++ type Slots = ( button :: forall query. H.Slot query Void Int )++ _button = Proxy :: Proxy &quot;button&quot; parent :: forall query input output m. H.Component query input output m parent = H.mkComponent { initialState: identity , render , eval: H.mkEval H.defaultEval } where- render :: forall state action. state -&amp;gt; H.ComponentHTML action () m+ render :: forall state action. state -&amp;gt; H.ComponentHTML action Slots m render _ =- HH.div_ [ button { label: &quot;Click Me&quot; } ]+ HH.div_ [ HH.slot_ _button 0 button { label: &quot;Click Me&quot; } ]我们的父组件现在正在渲染一个子组件 —— 我们的按钮组件。渲染一个组件引入了两个大的变化: 我们使用了slot_函数来渲染组件，它带有几个我们还没有探索过的参数。其中两个参数是button组件本身和它需要作为input的标签。 我们添加了一个名为Slots的新类型，这是一个row包含我们的button组件的标签，其值为H.Slot，我们在ComponentHTML中使用了这个新类型，而不是我们之前看到的空行()。slot和slot_函数以及Slot类型允许您在Halogen HTML中渲染一个stateful、effectful的子组件，就像它是任何其他HTML元素一样。但是为什么有这么多参数和类型涉及到这样做呢？为什么我们不能用它的input调用button？答案是Halogen为父子组件提供了两种相互通信的方式，我们需要确保这种通信是类型安全的。slot函数允许我们: 决定如何通过标签(类型级别的字符串button，我们在术语级别用代理Proxy :: Proxy &quot;button&quot;表示)和唯一标识符来标识特定组件(在本例中为整数0)以便我们可以向它发送查询。这是父组件与子组件之间必不可少的沟通形式。 渲染组件(button)并为其提供input（{ label: &quot;Click Me&quot; }），每次父组件渲染时都会重新发送，以防input随时间发生变化。这是一种从父组件到子组件的声明式沟通形式。 决定如何处理来自子组件的output消息。slot函数允许您为子组件的output提供handler处理程序，而slot_函数可以在子组件没有任何output或您想忽略它们时使用。这是子组件与父组件之间的沟通。slot和slot_函数以及H.Slot类型让我们以类型安全的方式管理这三种通信机制。在本章的其余部分，我们将重点关注父组件和子组件如何相互通信，并在此过程中探索slots和slot类型。组件间通信当您从使用一个组件转向使用多个组件时，您很快就会需要某种方式让它们相互通信。在Halogen中，父组件和子组件可以通过三种方式直接通信: 父组件可以向子组件提供input。每次父组件渲染时，它都会再次发送input，然后由子组件决定如何处理新input。 子组件可以向父组件发送output消息，类似于我们目前使用订阅的方式。子组件可以在发生重要事件时通知父组件，就像modal关闭或提交表单一样，然后父组件可以决定要做什么。 父组件可以查询子组件，或者告诉它做某事，或者通过从它那里请求一些信息。父组件可以决定何时需要子组件做某事或给它一些信息，然后由子组件来处理query。这三种机制为您提供了多种组件之间通信的方式。让我们简要探讨一下这三种机制，然后我们将看到您为组件定义的slot函数和slot类型如何帮助您以类型安全的方式使用它们。Input父组件可以向子组件提供input，该input在每次渲染时发送。我们已经多次看到这种情况 —— input类型用于生成子组件的初始状态。在介绍本章的示例中，我们的button组件从父组件接收了它的标签。到目前为止，我们只使用input来生成我们的初始状态。但是一旦创建了初始状态，input就不会停止。input在每次渲染时再次发送，子组件可以通过其eval规范中的receive函数处理新的input。receive :: input -&amp;gt; Maybe actioneval规范中的receive函数应该提醒你initialize和finalize，当组件创建和销毁时它让你选择一个action来评估. 以同样的方式，当父组件发生新的input时，receive函数让您可以选择一个action来评估。默认情况下，当接收到新input时，Halogen的defaultSpec不提供要评估的action。如果您的子组件在收到初始值后不需要做任何事情，那么您可以保持原样。例如，一旦我们的按钮收到它的标签并将其复制到state中，就没有必要继续监听input，以防它随着时间的推移而改变。每次父组件渲染时接收新input的能力是一项强大的功能。这意味着父组件可以声明性地为子组件提供值。父组件还有其他方式与子组件通信，但input的声明性使其成为大多数情况下的最佳选择。让我们通过重新审视介绍中的示例来具体说明这一点。在这个版本中，我们的button是未改变的 —— 它接收它的标签作为input并使用它来设置它的初始状态 —— 但是我们的父组件已经改变了. 我们的父组件现在在初始化时启动一个计时器，每秒增加一个计数，并将状态中的计数用作按钮的标签。简而言之，我们按钮的input将每秒钟重新发送一次。尝试将其粘贴到Try PureScript中，看看会发生什么 —— 我们按钮的标签是否每秒更新一次？module Main whereimport Preludeimport Control.Monad.Rec.Class (forever)import Data.Maybe (Maybe(..))import Effect (Effect)import Effect.Aff (Milliseconds(..))import Effect.Aff as Affimport Effect.Aff.Class (class MonadAff)import Halogen as Himport Halogen.Aff (awaitBody, runHalogenAff)import Halogen.HTML as HHimport Halogen.Subscription as HSimport Halogen.VDom.Driver (runUI)import Type.Proxy (Proxy(..))main :: Effect Unitmain = runHalogenAff do body &amp;lt;- awaitBody runUI parent unit bodytype Slots = ( button :: forall q. H.Slot q Void Unit )_button = Proxy :: Proxy &quot;button&quot;type ParentState = { count :: Int }data ParentAction = Initialize | Incrementparent :: forall query input output m. MonadAff m =&amp;gt; H.Component query input output mparent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , initialize = Just Initialize } } where initialState :: input -&amp;gt; ParentState initialState _ = { count: 0 } render :: ParentState -&amp;gt; H.ComponentHTML ParentAction Slots m render { count } = HH.div_ [ HH.slot_ _button unit button { label: show count } ] handleAction :: ParentAction -&amp;gt; H.HalogenM ParentState ParentAction Slots output m Unit handleAction = case _ of Initialize -&amp;gt; do { emitter, listener } &amp;lt;- H.liftEffect HS.create void $ H.subscribe emitter void $ H.liftAff $ Aff.forkAff $ forever do Aff.delay $ Milliseconds 1000.0 H.liftEffect $ HS.notify listener Increment Increment -&amp;gt; H.modify_ \\st -&amp;gt; st { count = st.count + 1 }-- 现在我们转向我们的子组件，按钮type ButtonInput = { label :: String }type ButtonState = { label :: String }button :: forall query output m. H.Component query ButtonInput output mbutton = H.mkComponent { initialState , render , eval: H.mkEval H.defaultEval } where initialState :: ButtonInput -&amp;gt; ButtonState initialState { label } = { label } render :: forall action. ButtonState -&amp;gt; H.ComponentHTML action () m render { label } = HH.button_ [ HH.text label ]如果您将其加载到Try PureScript中，您将看到我们的按钮…永远不会改变！即使父组件每秒都在向它发送新input(每​​次父组件重新渲染)，我们的子组件也永远不会收到它。仅仅接受input是不够的, 我们还需要明确决定每次收到它时要做什么。尝试用这个修改后的代码替换按钮代码以查看不同之处:data ButtonAction = Receive ButtonInputtype ButtonInput = { label :: String }type ButtonState = { label :: String }button :: forall query output m. H.Component query ButtonInput output mbutton = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , receive = Just &amp;lt;&amp;lt;&amp;lt; Receive } } where initialState :: ButtonInput -&amp;gt; ButtonState initialState { label } = { label } render :: ButtonState -&amp;gt; H.ComponentHTML ButtonAction () m render { label } = HH.button_ [ HH.text label ] handleAction :: ButtonAction -&amp;gt; H.HalogenM ButtonState ButtonAction () output m Unit handleAction = case _ of -- 当我们收到新的input时，我们会更新状态中的`label`字段。 Receive input -&amp;gt; H.modify_ _ { label = input.label }我们在新版本中进行了几处更改，以确保我们与来自父组件的input保持同步: 我们添加了一个新动作Receive，一个接受Input类型作为其参数的构造函数。然后我们通过在接收到新input时更新我们的状态来在我们的handleAction函数中处理这个action。 我们在eval规范中添加了一个新字段，receive，它包含一个函数，每次接收到新input时都会调用该函数。我们的函数会返回我们的Receive操作，以便对其进行评估。此更改足以让我们的子组件订阅来自父组件的新input。您现在应该看到我们按钮的标签每秒更新一次. 作为练习，您可以用const Nothing替换我们的receive函数，以再次查看input是如何被忽略的。Output消息有时一个事件发生在 它不应该自己处理的 子组件中。例如，假设我们正在编写一个modal组件，当用户单击以关闭modal时，我们需要评估一些代码。为了保持这个modal的灵活性，我们希望父组件决定当modal关闭时应该发生什么。在Halogen中，我们通过设计modal(子组件)来向父组件发出output消息来处理这种情况。然后，父组件可以像处理其handleAction函数中的任何其他操作一样处理该消息。从概念上讲，就好像子组件是父组件自动订阅的订阅。具体来说，我们的modal可以向父组件提出一个Closed输出。然后，父级可以更改其状态以指示不应再显示modal，并在下一次渲染时将modal从DOM中删除。作为一个小例子，让我们考虑如何设计一个按钮，让父组件决定点击它时要做什么:module Button where-- 这个组件可以通知父组件一个事件，`Clicked`data Output = Clicked-- 这个组件可以处理一个内部事件，`Click`data Action = Click-- 我们的output类型显示在我们的 `Component` 类型中button :: forall query input m. H.Component query input Output mbutton = H.mkComponent { initialState: identity , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } } where render _ = HH.button [ HE.onClick \\_ -&amp;gt; Click ] [ HH.text &quot;Click me&quot; ] -- 我们的output类型也显示在我们的 `HalogenM` 类型中, 因为这是我们可以发出这些output消息的地方。 handleAction :: forall state. Action -&amp;gt; H.HalogenM state Action () Output m Unit handleAction = case _ of -- 当按钮被点击时，我们通过使用`H.raise`发出它来通知父组件`Clicked`事件已经发生。 Click -&amp;gt; H.raise Clicked我们采取了一些步骤来实现此output消息。 我们添加了一个Output类型，它描述了我们的组件可以发出哪些output消息. 我们在Component类型中使用该类型是因为它是组件公共接口的一部分，而我们的HalogenM类型使用它是因为这是我们可以实际发出output消息的地方。 我们添加了一个带有Click构造函数的Action类型来处理Halogen HTML中的单击事件. 我们通过向父组件发送output消息来处理我们的handleAction中的Click操作。您可以使用H.raise函数发出output消息。我们现在知道组件如何发出output消息。现在，让我们看看如何处理来自子组件的output消息。有以下三点需要牢记: 当您渲染一个子组件时，您需要将它添加到您的slots类型中，然后在您的ComponentHTML和HalogenM类型中使用它。您添加的类型将包括子组件的output消息类型，它允许编译器验证您的处理程序。 当您使用slot函数渲染子组件时，您可以提供一个应在出现新output时评估的action。这类似于initialize等生命周期函数如何接受一个action来评估组件何时初始化。 然后，您需要在您的handleAction添加一个case操作，用于(您添加的action来)处理子组件的output。让我们通过编写一个slot类型来开始编写我们的父组件:module Parent whereimport Button as Buttontype Slots = ( button :: forall query. H.Slot query Button.Output Int )-- 我们可以使用符号代理来引用`button`标签，这是一种在值级别引用像`button`这样的类型级别字符串的方式。-- 我们定义这个是为了方便，所以我们可以使用`_button`在slot类型中引用它的标签，而不是一遍遍地写`Proxy`。_button = Proxy :: Proxy &quot;button&quot;我们的slot类型是一个row，其中每个标签指定我们支持的特定类型的子组件，在每种情况下都使用类型H.Slot:H.Slot query output id该类型记录了可以发送到该类型组件的queries、我们可以从该组件处理的output消息, 以及我们可以用来唯一标识单个组件的类型。例如，考虑一下我们可以渲染10个这样的按钮组件 —— 您如何知道向哪个组件发送查询？这就是插槽id发挥作用的地方。我们将在讨论查询时了解更多相关信息。我们的父组件的row类型清楚地表明我们可以支持一种类型的子组件，我们可以通过符号button和Int类型的标识符来引用它. 我们无法向该组件发送query，因为类型变量保持打开状态。但它可以向我们发送Button.Output类型的output。接下来，我们需要提供一个action来处理这些output:data Action = HandleButton Button.Output当这个action发生在我们的组件中时，我们可以解开它以获取Button.Output值并使用它来决定要评估的代码。现在我们已经处理了我们的slot和action类型，让我们编写我们的父组件:parent :: forall query input output m. H.Component query input output mparent = H.mkComponent { initialState: identity , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } } where render :: forall state. state -&amp;gt; H.ComponentHTML Action Slots m render _ = HH.div_ [ HH.slot _button 0 button unit HandleButton ] handleAction :: forall state. Action -&amp;gt; H.HalogenM state Action Slots output m Unit handleAction = case _ of HandleButton output -&amp;gt; case output of Button.Clicked -&amp;gt; do ...您会注意到我们的Slots类型现在已用于ComponentHTML类型和HalogenM类型。此外，现在每当Button.Clicked事件在子组件中发生时都会通知该组件，这让父组件可以评估它想要的任何代码作为响应。就是这样！您现在知道如何将output消息从子组件提升到父组件以及如何在父组件中处理这些消息. 这是子组件与父组件通信的主要方式。现在让我们看看父组件如何向子组件发送信息。Queries查询表示父组件可以发送给子组件的命令或请求。它们类似于action，并使用类似于handleAction函数的handleQuery函数进行处理。但它们是从组件外部产生的，而不是像action那样在组件内部，这意味着它们是组件公共接口的一部分。当父组件需要控制事件何时发生而不是子组件时，查询最有用。例如: 父组件可以告诉表单提交，而不是等待用户单击提交按钮。 父组件可以从autocomplete请求当前的选择，而不是在做出选择时等待子组件的output消息.查询是父组件强制控制子组件的一种方式。正如我们在两个示例中所介绍的，有两种常见的查询样式: 当父组件命令子组件做某事时的tell风格的查询，以及当父组件想要从子组件获取信息时的request风格的查询。父组件可以发送query，但子组件定义query并处理query。这使得query在概念上类似于action: 就像如何定义Action类型并使用handleAction为组件处理action一样，您可以为queries定义Query类型和handleQuery函数。下面是一个查询类型的简短示例，其中包括tell-style和request-style查询:data Query a = Tell a | Request (Boolean -&amp;gt; a)我们可以将这个查询解释为”一个父组件可以使用tell函数告诉这个组件做一些事情，也可以使用request函数从这个组件请求一个布尔值.” 当我们实现查询类型时，请记住a类型参数应出现在每个构造函数中。它应该是tell风格查询的最后一个参数，并且是request风格查询的函数类型的结果。在eval规范中使用handleQuery函数处理query，就像使用handleAction函数处理action一样. 让我们为我们的自定义数据类型编写一个handleQuery函数，假设已经定义了一些state、action和output类型:handleQuery :: forall a m. Query a -&amp;gt; H.HalogenM State Action () Output m (Maybe a)handleQuery = case _ of Tell a -&amp;gt; -- ... 做一些事情，然后返回我们收到的`a` pure (Just a) Request reply -&amp;gt; -- ... 做一些事情，然后将请求的`Boolean`提供给`reply`函数以生成我们需要返回的`a` pure (Just (reply true))handleQuery函数接受类型为Query a的query并生成一些返回Maybe a的HalogenM代码。这就是为什么我们的query类型的每个构造函数都需要包含一个a: 我们需要在handleQuery中返回它。当我们收到一个tell风格的查询时，我们可以将我们收到的a包装在Just中以返回它，就像我们在handleQuery中处理Tell a的case所做的那样.但是，当我们收到request风格的查询时，我们必须做更多的工作。我们接收的不是一个我们可以返回的a值，而是一个函数，该函数会给我们一个a然后我们可以返回. 例如，在我们的Request (Boolean -&amp;gt; a)示例中，我们收到一个函数(当我们将它应用于Boolean时，它会给我们一个a). 按照惯例，当您对request风格的查询进行模式匹配时，此函数称为reply。在handleQuery中，我们给这个函数一个true以获取a，然后将a包裹在Just中以返回它。request风格的查询起初可能看起来很奇怪。但是该风格允许我们的query类型返回多种类型的值，而不是只返回一种类型的值。以下是一些返回不同内容的不同请求类型:data Requests a = GetInt (Int -&amp;gt; a) | GetRecord ({ a :: Int, b :: String } -&amp;gt; a) | GetString (String -&amp;gt; a) | ...父组件可以使用GetInt从我们的组件中检索一个Int，使用GetString从我们的组件中检索一个String，等等。您可以考虑query类型返回的a类型，而request风格的查询是一种让a成为许多不同可能类型的方法。稍后我们将看到如何从父组件执行此操作。让我们看另一个小例子，它演示了如何在组件中定义和处理queries:-- 该组件可以被告知`increment`或可以回答当前`count`的请求data Query a = Increment a | GetCount (Int -&amp;gt; a)type State = { count :: Int }-- 我们的query类型显示在我们的 `Component` 类型中counter :: forall input output m. H.Component Query input output mcounter = H.mkComponent { initialState: \\_ -&amp;gt; { count: 0 } , render , eval: H.mkEval $ H.defaultEval { handleQuery = handleQuery } } where render { count } = HH.div_ [ HH.text $ show count ] -- 我们编写了一个函数来处理出现的查询 handleQuery :: forall action a. Query a -&amp;gt; H.HalogenM State action () output m (Maybe a) handleQuery = case _ of -- 当我们收到 `Increment` 查询时，我们将增加我们的状态 Increment a -&amp;gt; do H.modify_ \\state -&amp;gt; state { count = state.count + 1 } pure (Just a) -- 当我们收到 `GetCount` 查询时，我们将用`state`进行答复。 GetCount reply -&amp;gt; do { count } &amp;lt;- H.get pure (Just (reply count))在这个例子中，我们定义了一个计数器，让父组件来tell它增加或请求它的当前计数。为此，我们: 实现了一个查询类型，包括一个tell风格的查询，Increment a，和一个request风格的查询，GetCount (Int -&amp;gt; a)。我们将此查询类型添加到组件的公共接口Component中。 实现了一个查询处理程序handleQuery，它在这些查询出现时运行代码。我们将把它添加到我们的eval中。我们现在知道如何定义queries并在子组件中评估它们。现在，让我们看看如何从父组件向子组件发送query。像往常一样，我们可以从定义父组件的slot类型开始:module Parent wheretype Slots = ( counter :: H.Slot Counter.Query Void Int )_counter = Proxy :: Proxy &quot;counter&quot;我们的slot类型使用其query类型记录了counter组件，并将其output消息类型保留为Void，以表示没有。当我们的父组件初始化时，我们将从子组件获取计数，然后increment它，然后再次获取计数，以便我们可以看到它增加了。为此，我们需要在初始化时运行一个action:data Action = Initialize现在，我们可以继续我们的组件定义:parent :: forall query input output m. H.Component query input output mparent = H.mkComponent { initialState: identity , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , initialize = Just Initialize } } where render :: forall state. state -&amp;gt; H.ComponentHTML Action Slots m render _ = HH.div_ [ HH.slot_ _counter unit counter unit ] handleAction :: forall state. Action -&amp;gt; H.HalogenM state Action Slots output m Unit handleAction = case _ of Initialize -&amp;gt; -- startCount :: Maybe Int startCount &amp;lt;- H.request _counter unit Counter.GetCount -- _ :: Maybe Unit H.tell _counter unit Counter.Increment -- endCount :: Maybe Int endCount &amp;lt;- H.request _counter unit Counter.GetCount when (startCount /= endCount) do -- ... do something这里有几件事情需要注意。 我们在slot类型中使用了计数器标签的代理，_counter，连同它的标识符，unit，既可以使用slot函数渲染组件，也可以使用tell和request函数向组件发送查询。标签和标识符始终用于处理特定的子组件。 我们使用H.tell函数发送tell风格的查询Increment，使用H.request函数发送request风格的查询GetCount。GetCount查询有一个类型为(Int -&amp;gt; a)的reply函数，因此您会注意到，当我们使用它时，我们收到了一个Maybe Int的响应。tell和request函数接受一个标签、一个slot标识符和一个要发送的查询。tell函数不返回任何东西，但request函数返回来自child组件的响应(包裹在Maybe中)，其中Nothing表示查询失败(子组件返回Nothing，或者您提供的标签和slot标识符中不存在任何组件).还有tellAll和requestAll函数向给定标签的所有组件发送相同的查询。许多人发现查询是Halogen库中最令人困惑的部分. 幸运的是，查询的使用率远不如我们在本指南中了解的其他Halogen功能，如果您遇到困难，您可以随时参考指南的这一部分。组件插槽我们已经学到了很多关于组件如何相互通信的知识。在我们继续我们的最后一个例子之前，让我们回顾一下我们在此过程中学到的关于slots的知识。一个组件需要知道它支持什么类型的子组件，以便它能够与它们通信。它需要知道它可以向子组件发送哪些查询以及它可以从子组件那里接收哪些output消息。它还需要知道如何识别向哪个特定组件发送query。H.Slot类型捕获父组件可以支持的特定类型的子组件的query、output和唯一标识符。您可以将许多插槽组合成一个row插槽，其中每个标签用于特定类型的组件。以下是如何读取几个不同插槽的类型定义的方法:type Slots = ()这意味着该组件不支持子组件。type Slots = ( button :: forall query. H.Slot query Void Unit )这意味着组件支持一种类型的子组件，由符号button标识。您不能向它发送查询(因为q是一个开放类型变量)并且它不会发出任何output消息(通常用Void表示，因此您可以使用absurd作为处理程序).您最多可以拥有该组件中的一个，因为只有一个值unit位于Unit类型中。type Slots = ( button :: forall query. H.Slot query Button.Output Int )这种类型与前一种非常相似。不同之处在于子组件可以引发Button.Output类型的output消息，并且您可以拥有与整数一样多的此组件。type Slots = ( button :: H.Slot Button.Query Void Int , modal :: H.Slot Modal.Query Modal.Output Unit )这种slot类型意味着组件支持两种类型的子组件，由标签button和modal标识。您可以将Button.Query类型的query发送到button组件，并且您不会从它收到任何output消息. 您可以向modal组件发送类型为Modal.Query的query并从modal组件接收类型为Modal.Output的消息。您可以拥有与整数一样多的button组件，但最多只有一个modal组件。Halogen应用程序中的一个常见模式是组件导出自己的slot类型，因为它已经知道其query和消息类型，而不导出标识此特定组件的类型，因为这是父组件的责任。例如，如果button和modal组件模块导出自己的slot类型，如下所示:module Button wheretype Slot id = H.Slot Query Void idmodule Modal wheretype Slot id = H.Slot Query Output id那么我们最后一个slot类型示例将变成这个更简单的类型:type Slots = ( button :: Button.Slot Int , modal :: Modal.Slot Unit )这样做的优点是更简洁，更容易随着时间的推移保持最新状态，就好像slot类型发生更改一样，它们可能发生在源模块中，而不是在使用slot类型的任何地方。完整示例最后，我们使用本章中讨论的所有通信机制编写了一个父组件和子组件的示例。该示例注释了我们如何解释最重要的代码行 —— 我们通过浏览我们自己的代码库中的这些组件定义而收集到的内容。像往常一样，我们建议将此代码粘贴到Try PureScript中，以便您可以交互地探索它。module Main whereimport Preludeimport Data.Maybe (Maybe(..))import Effect (Effect)import Effect.Class (class MonadEffect)import Effect.Class.Console (logShow)import Halogen as Himport Halogen.Aff as HAimport Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.VDom.Driver (runUI)import Type.Proxy (Proxy(..))main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI parent unit body-- 父组件支持一种类型的子组件，它使用 `ButtonSlot` 插槽类型。 您可以拥有与整数一样多的此类子组件。type Slots = ( button :: ButtonSlot Int )-- 父组件只能评估一个动作: 处理来自`button`组件的`output`消息，类型为&quot;ButtonOutput&quot;.data ParentAction = HandleButton ButtonOutput-- 父组件在本地状态中保持其所有子组件按钮被点击的次数。type ParentState = { clicked :: Int }-- 父组件不使用自己的查询、输入或输出类型。它可以使用任何 monad，只要该 monad 可以运行 `Effect` 函数。parent :: forall query input output m. MonadEffect m =&amp;gt; H.Component query input output mparent = H.mkComponent { initialState , render -- 该组件可以处理的唯一内部事件是在 `ParentAction` 类型中定义的操作。 , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } } where initialState :: input -&amp;gt; ParentState initialState _ = { clicked: 0 } -- 我们渲染了三个按钮，使用`HandleButton`操作处理它们的`output`消息。 -- 当我们的状态改变时，这个渲染函数将再次运行，每次发送新的input(包含一个新标签供子按钮组件使用.) render :: ParentState -&amp;gt; H.ComponentHTML ParentAction Slots m render { clicked } = do let clicks = show clicked HH.div_ [ -- 我们用插槽id 0 渲染我们的第1个按钮 HH.slot _button 0 button { label: clicks &amp;lt;&amp;gt; &quot; Enabled&quot; } HandleButton -- 我们用插槽id 1 渲染我们的第2个按钮 , HH.slot _button 1 button { label: clicks &amp;lt;&amp;gt; &quot; Power&quot; } HandleButton -- 我们用插槽id 2 渲染我们的第3个按钮 , HH.slot _button 2 button { label: clicks &amp;lt;&amp;gt; &quot; Switch&quot; } HandleButton ] handleAction :: ParentAction -&amp;gt; H.HalogenM ParentState ParentAction Slots output m Unit handleAction = case _ of -- 我们处理一个动作，`HandleButton`，它自己处理我们按钮组件的`output`消息。 HandleButton output -&amp;gt; case output of --只有一个`output`消息，`Clicked`。 Clicked -&amp;gt; do -- 当 `Clicked` 消息出现时，我们将增加 state 中的点击计数，然后向第一个按钮发送一个查询，并告诉它为 `true`， -- 然后向 所有请求其当前启用状态的子组件 发送一个查询，我们记录日志到控制台。 H.modify_ \\state -&amp;gt; state { clicked = state.clicked + 1 } H.tell _button 0 (SetEnabled true) on &amp;lt;- H.requestAll _button GetEnabled logShow on-- 我们现在转到子组件，一个名为`button`的组件。-- 该组件可以接受`ButtonQuery`类型的查询并发送`ButtonOutput`类型的`output`消息。-- 导出此插槽类型，以便其他组件在构建其插槽`row`时可以使用它。type ButtonSlot = H.Slot ButtonQuery ButtonOutput-- We think our button will have the label &quot;button&quot; in the row where it&#39;s used,-- so we&#39;re exporting a symbol proxy for convenience.-- 我们认为我们的按钮将在使用它的`row`中带有标签`button`，因此为方便起见，我们导出了一个符号代理。_button = Proxy :: Proxy &quot;button&quot;-- 该组件接受两个查询。第一个是`request`风格的查询，它让父组件从我们这里请求一个`Boolean` 值。-- 第二个是`tell`风格的查询，它让父组件向我们发送一个`Boolean`值。data ButtonQuery a = GetEnabled (Boolean -&amp;gt; a) | SetEnabled Boolean a-- 这个组件可以通知父组件一个事件，`Clicked`data ButtonOutput = Clicked-- 该组件可以处理两个内部操作。它可以评估`Click`操作，并且可以在其父组件重新渲染时接收新`input`。data ButtonAction = Click | Receive ButtonInput-- 这个组件接收一个标签作为输入type ButtonInput = { label :: String }-- 该组件在状态中存储标签和启用标志type ButtonState = { label :: String, enabled :: Boolean }-- 该组件支持`ButtonQuery`类型的查询，需要`ButtonInput`类型的输入，并且可以发送`ButtonOutput`类型的`output`。-- 它不执行任何`effects`，我们可以看出这是因为`m`类型参数没有约束。button :: forall m. H.Component ButtonQuery ButtonInput ButtonOutput mbutton = H.mkComponent { initialState , render -- 该组件可以处理内部操作，处理父组件发送的`query`，并在收到新`input`时进行更新。 , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , handleQuery = handleQuery , receive = Just &amp;lt;&amp;lt;&amp;lt; Receive } } where initialState :: ButtonInput -&amp;gt; ButtonState initialState { label } = { label, enabled: false } -- This component has no child components. When the rendered button is clicked -- we will evaluate the `Click` action. -- 该组件没有子组件。点击已渲染的按钮时，我们将评估`Click`操作。 render :: ButtonState -&amp;gt; H.ComponentHTML ButtonAction () m render { label, enabled } = HH.button [ HE.onClick \\_ -&amp;gt; Click ] [ HH.text $ label &amp;lt;&amp;gt; &quot; (&quot; &amp;lt;&amp;gt; (if enabled then &quot;on&quot; else &quot;off&quot;) &amp;lt;&amp;gt; &quot;)&quot; ] handleAction :: ButtonAction -&amp;gt; H.HalogenM ButtonState ButtonAction () ButtonOutput m Unit handleAction = case _ of -- 当我们收到新的`input`时，我们会更新状态中的`label`字段。 Receive input -&amp;gt; H.modify_ _ { label = input.label } -- 当按钮被点击时，我们更新我们的`enabled`字段，并通知我们的父组件发生了 `Clicked` 事件。 Click -&amp;gt; do H.modify_ \\state -&amp;gt; state { enabled = not state.enabled } H.raise Clicked handleQuery :: forall a . ButtonQuery a -&amp;gt; H.HalogenM ButtonState ButtonAction () ButtonOutput m (Maybe a) handleQuery = case _ of -- 当我们收到带有布尔值的`tell`风格的`SetEnabled`查询时，我们在state中设置该值。 SetEnabled value next -&amp;gt; do H.modify_ _ { enabled = value } pure (Just next) -- 当我们收到一个`request`风格的`GetEnabled`查询时，它需要一个布尔结果，我们从我们的状态中获取一个布尔值并用它来回复。 GetEnabled reply -&amp;gt; do enabled &amp;lt;- H.gets _.enabled pure (Just (reply enabled))在下一章中，我们将了解有关运行Halogen应用程序的更多信息。" }, { "title": "Halogen-05-生命周期和订阅", "url": "/posts/Halogen-05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A2%E9%98%85/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "生命周期和订阅到目前为止，您学到的概念涵盖了您将编写的大多数Halogen组件。大多数组件都有内部状态，呈现HTML元素，并通过在用户单击、悬停或以其他方式与呈现的HTML交互时执行操作来做出响应。但是actions也可以从其他类型的事件内部产生。下面是一些常见的例子: 您需要在组件启动时运行一个action(例如，您需要执行一个effect来获得您的初始状态)或者当组件从DOM中移除时(例如，清理您获得的资源)。这些被称为生命周期事件。 您需要定期运行action(例如，您需要每10秒执行一次更新),或者当一个事件发生在你渲染的HTML之外时(例如，你需要在DOM窗口上按下一个键时运行一个action, 或者您需要处理在第三方组件(如文本编辑器)中发生的事件)。这些由订阅处理。当我们在下一章学习父组件和子组件时，我们将学习在组件中产生action的另一种方式。本章将重点介绍生命周期和订阅。生命周期事件每个Halogen组件都可以访问两个生命周期事件: 组件可以在初始化时评估一个action(Halogen创建它) 组件可以在完成时评估一个action(Halogen删除它)我们指定当组件作为eval函数的一部分进行初始化和最终确定时要运行的action(如果有的话)，这与我们提供handleAction函数的位置相同。在下一节中，我们将更详细地了解eval是什么，但首先让我们看一个正在运行的生命周期示例。下面的示例与我们的随机数组件几乎相同，但有一些重要的变化: 除了现有的Regenerate操作之外，我们还添加了Initialize和Finalize。 我们已经扩展了我们的eval以包含一个initialize字段，该字段声明应在组件初始化时评估我们的Initialize操作，以及一个finalize字段, 该声明应在组件完成时评估我们的Finalize操作的。 由于我们有两个新action，因此我们在handleAction函数中添加了两个新case来描述如何处理它们。尝试通读示例:module Main whereimport Preludeimport Data.Maybe (Maybe(..), maybe)import Effect (Effect)import Effect.Class (class MonadEffect)import Effect.Class.Console (log)import Effect.Random (random)import Halogen as Himport Halogen.Aff as HAimport Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit bodytype State = Maybe Numberdata Action = Initialize | Regenerate | Finalizecomponent :: forall query input output m. MonadEffect m =&amp;gt; H.Component query input output mcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , initialize = Just Initialize , finalize = Just Finalize } }initialState :: forall input. input -&amp;gt; StateinitialState _ = Nothingrender :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender state = do let value = maybe &quot;No number generated yet&quot; show state HH.div_ [ HH.h1_ [ HH.text &quot;Random number&quot; ] , HH.p_ [ HH.text (&quot;Current value: &quot; &amp;lt;&amp;gt; value) ] , HH.button [ HE.onClick \\_ -&amp;gt; Regenerate ] [ HH.text &quot;Generate new number&quot; ] ]handleAction :: forall output m. MonadEffect m =&amp;gt; Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Initialize -&amp;gt; do handleAction Regenerate newNumber &amp;lt;- H.get log (&quot;Initialized: &quot; &amp;lt;&amp;gt; show newNumber) Regenerate -&amp;gt; do newNumber &amp;lt;- H.liftEffect random H.put (Just newNumber) Finalize -&amp;gt; do number &amp;lt;- H.get log (&quot;Finalized! Last number was: &quot; &amp;lt;&amp;gt; show number)当这个组件挂载时，我们将生成一个随机数并将其记录到控制台。当用户单击按钮时，我们将不断重新生成随机数，当这个组件从DOM中移除时，它会记录它在状态中的最后一个数字。我们在这个例子中做了另一个有趣的改变: 在我们的Initialize处理程序中，我们调用了handleAction Regenerate – 我们递归地调用了handleAction. 正如我们在这里所做的那样，不时从其他actions中调用actions会很方便。我们也可以内联Regenerate的处理程序 —— 下面的代码做同样的事情:Initialize -&amp;gt; do newNumber &amp;lt;- H.liftEffect random H.put (Just newNumber) log (&quot;Initialized: &quot; &amp;lt;&amp;gt; show newNumber)在我们转向订阅之前，让我们先谈谈eval函数。eval函数，mkEval和EvalSpec我们一直在我们所有的组件中使用eval，但到目前为止我们只通过handleAction函数处理了由我们的Halogen HTML产生的action。 但是eval函数可以描述我们的组件可以评估HalogenM代码以响应事件的所有方式。在绝大多数情况下，您不需要太关心下面描述的组件规范和评估规范中涉及的所有类型和函数，但我们将简要分解这些类型，以便您了解发生了什么。mkComponent函数接受一个ComponentSpec，它是一个包含三个字段的记录:H.mkComponent { initialState :: input -&amp;gt; state , render :: state -&amp;gt; H.ComponentHTML action slots m , eval :: H.HalogenQ query action input ~&amp;gt; H.HalogenM state action slots output m }我们已经在initialState和render函数上花费了大量时间。但是eval函数可能看起来很奇怪 —— 什么是HalogenQ，handleAction之类的函数是如何适应的？现在，我们将重点介绍此函数的最常见用法，但您可以在概念参考中找到完整的详细信息。eval函数描述了如何处理组件中出现的事件。它通常是通过将mkEval函数应用于EvalSpec来构建的，与我们将mkComponent应用于ComponentSpec以生成Component的方式相同。为方便起见, Halogen提供了一个名为defaultEval的已经完成的EvalSpec，它在组件中出现事件时不执行任何操作。通过使用这个默认值，你可以只覆盖你关心的值，而其余的值可以什么都不做。以下是我们如何定义目前仅处理action的eval函数:H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } }-- 假设我们已经在范围内定义了一个`handleAction`函数...handleAction = ...注意：initialState和render使用缩写record双关符号设置; 但是，在这种情况下，handleAction不能设置为双关语，因为它是Records更新的一部分, Records语言参考中提供了有关record双关语和record更新语法的更多信息。如果需要，您可以覆盖更多字段。例如，如果您需要支持初始化程序，那么您也将覆盖initialize字段:H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , initialize = Just Initialize } }让我们快速浏览一下EvalSpec的完整类型:type EvalSpec state query action slots input output m = { handleAction :: action -&amp;gt; HalogenM state action slots output m Unit , handleQuery :: forall a. query a -&amp;gt; HalogenM state action slots output m (Maybe a) , initialize :: Maybe action , receive :: input -&amp;gt; Maybe action , finalize :: Maybe action }EvalSpec涵盖了组件内部可用的所有类型。幸运的是，您无需在任何地方指定此类型 —— 您只需向mkEval提供一条record即可. 我们将在下一章介绍handleQuery和receive函数以及query和output类型，因为它们只与子组件相关。由于在正常使用中，您将覆盖defaultEval中的特定字段，而不是自己写出整个eval规范，让我们也看看defaultEval为这些函数中的每一个实现了什么:defaultEval = { handleAction: const (pure unit) , handleQuery: const (pure Nothing) -- 我们将在介绍子组件时了解这一点 , receive: const Nothing -- 我们将在介绍子组件时了解这一点 , finalize: Nothing }现在，让我们转到内部事件的另一个常见来源: 订阅。订阅有时您需要处理内部出现的事件，这些事件不是来自与您呈现的Halogen HTML交互的用户。两个常见的来源是基于时间的actions和事件，它们发生在您渲染的元素之外(如浏览器窗口)。在Halogen中，可以使用halogen-subscriptions库手动创建这些类型的事件。Halogen组件可以通过提供应该在发射器触发时运行的action来订阅 Emitter。您可以使用halogen-subscriptions库中的函数订阅事件，但Halogen提供了一个特殊的帮助函数，用于订阅DOM中称为eventListener的事件侦听器。一个Emitter产生一个action流，只要它保持订阅emitter，你的组件就会评估这些action。创建一个emitter并在组件初始化时订阅它是很常见的，尽管您可以随时订阅或取消订阅一个emitter。让我们看一下订阅的两个示例: 一个基于Aff的计时器，它计算自组件mounted以来的秒数，以及一个基于事件侦听器的流，它报告文档上的键盘事件。实现一个Timer我们的第一个示例将使用基于Aff的计时器来每秒递增。module Main whereimport Preludeimport Control.Monad.Rec.Class (forever)import Data.Maybe (Maybe(..))import Effect (Effect)import Effect.Aff (Milliseconds(..))import Effect.Aff as Affimport Effect.Aff.Class (class MonadAff)import Effect.Exception (error)import Halogen as Himport Halogen.Aff as HAimport Halogen.HTML as HHimport Halogen.Subscription as HSimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit bodydata Action = Initialize | Ticktype State = Intcomponent :: forall query input output m. MonadAff m =&amp;gt; H.Component query input output mcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , initialize = Just Initialize } }initialState :: forall input. input -&amp;gt; StateinitialState _ = 0render :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender seconds = HH.text (&quot;You have been here for &quot; &amp;lt;&amp;gt; show seconds &amp;lt;&amp;gt; &quot; seconds&quot;)handleAction :: forall output m. MonadAff m =&amp;gt; Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Initialize -&amp;gt; do _ &amp;lt;- H.subscribe =&amp;lt;&amp;lt; timer Tick pure unit Tick -&amp;gt; H.modify_ \\state -&amp;gt; state + 1timer :: forall m a. MonadAff m =&amp;gt; a -&amp;gt; m (HS.Emitter a)timer val = do { emitter, listener } &amp;lt;- H.liftEffect HS.create _ &amp;lt;- H.liftAff $ Aff.forkAff $ forever do Aff.delay $ Milliseconds 1000.0 H.liftEffect $ HS.notify listener val pure emitter几乎所有这些代码都应该看起来很熟悉，但有两个新部分:首先，我们定义了一个可重用的Emitter，它将每秒广播一个我们选择的值，直到它没有订阅者:timer :: forall m a. MonadAff m =&amp;gt; a -&amp;gt; m (HS.Emitter a)timer val = do { emitter, listener } &amp;lt;- H.liftEffect HS.create _ &amp;lt;- H.liftAff $ Aff.forkAff $ forever do Aff.delay $ Milliseconds 1000.0 H.liftEffect $ HS.notify listener val pure emitter除非您正在创建与DOM中的事件侦听器相关联的emitters，否则您应该使用halal-subscriptions库中的函数。大多数情况下，您将使用HS.create创建一个emitter和一个listener，但如果您需要手动控制取消订阅，您也可以使用HS.makeEmitter。其次，我们使用Halogen的subscribe函数附加到emitter，同时提供我们想要每秒发射的特定action:Initialize -&amp;gt; do _ &amp;lt;- H.subscribe =&amp;lt;&amp;lt; timer Tick pure unitsubscribe函数将一个Emitter作为参数，并返回一个SubscriptionId。您可以随时将此SubscriptionId传递给Halogen取消订阅功能以结束订阅. 组件在完成时会自动结束其拥有的任何订阅，因此无需在此处取消订阅。您可能还对Ace编辑器示例感兴趣，该示例订阅在第三方JavaScript组件中发生的事件，并使用它们来触发Halogen组件中的action。使用事件监听器作为订阅使用订阅的另一个常见原因是当您需要对DOM中的事件做出反应时，这些事件不是直接由您控制的HTML元素产生的。例如，我们可能想要监听发生在document本身上的事件。在以下示例中，我们订阅document上的按键事件，保存按住Shift键时输入的任何字符，并在用户按下Enter键时停止监听。它演示了使用eventListener函数附加事件侦听器并使用H.unsubscribe函数选择何时清理它。在examples目录下也有对应的键盘输入的例子。module Main whereimport Preludeimport Data.Maybe (Maybe(..))import Data.String as Stringimport Effect (Effect)import Effect.Aff.Class (class MonadAff)import Halogen as Himport Halogen.Aff as HAimport Halogen.HTML as HHimport Halogen.Query.Event (eventListener)import Halogen.VDom.Driver (runUI)import Web.Event.Event as Eimport Web.HTML (window)import Web.HTML.HTMLDocument as HTMLDocumentimport Web.HTML.Window (document)import Web.UIEvent.KeyboardEvent as KEimport Web.UIEvent.KeyboardEvent.EventTypes as KETmain :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit bodytype State = { chars :: String }data Action = Initialize | HandleKey H.SubscriptionId KE.KeyboardEventcomponent :: forall query input output m. MonadAff m =&amp;gt; H.Component query input output mcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction , initialize = Just Initialize } }initialState :: forall input. input -&amp;gt; StateinitialState _ = { chars: &quot;&quot; }render :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender state = HH.div_ [ HH.p_ [ HH.text &quot;Hold down the shift key and type some characters!&quot; ] , HH.p_ [ HH.text &quot;Press ENTER or RETURN to clear and remove the event listener.&quot; ] , HH.p_ [ HH.text state.chars ] ]handleAction :: forall output m. MonadAff m =&amp;gt; Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Initialize -&amp;gt; do document &amp;lt;- H.liftEffect $ document =&amp;lt;&amp;lt; window H.subscribe&#39; \\sid -&amp;gt; eventListener KET.keyup (HTMLDocument.toEventTarget document) (map (HandleKey sid) &amp;lt;&amp;lt;&amp;lt; KE.fromEvent) HandleKey sid ev | KE.shiftKey ev -&amp;gt; do H.liftEffect $ E.preventDefault $ KE.toEvent ev let char = KE.key ev when (String.length char == 1) do H.modify_ \\st -&amp;gt; st { chars = st.chars &amp;lt;&amp;gt; char } | KE.key ev == &quot;Enter&quot; -&amp;gt; do H.liftEffect $ E.preventDefault (KE.toEvent ev) H.modify_ _ { chars = &quot;&quot; } H.unsubscribe sid | otherwise -&amp;gt; pure unit在这个例子中，我们使用了H.subscribe&#39;函数，它将SubscriptionId传递给emitter而不是返回它。这是一种替代方法，可以让您将ID保留在action类型而不是state中，这样会更方便。我们将emitter直接写入我们的代码中以处理Initialize操作，该操作在document上注册一个事件侦听器并在每次按下键时发出HandleKey。eventListener使用purescript-web库中的类型来处理DOM以手动构建事件侦听器:eventListener :: forall a . Web.Event.EventType -&amp;gt; Web.Event.EventTarget.EventTarget -&amp;gt; (Web.Event.Event -&amp;gt; Maybe a) -&amp;gt; HS.Emitter a它需要一种要监听的事件类型(在我们的例子中:keyup)，一个指示在哪里监听事件的目标(在我们的例子中: HTMLDocument本身)，以及一个将发生的事件转换为应该发出的类型的回调函数(在我们的例子中: 我们通过在HandleKey构造函数中捕获事件来发出我们的Action类型).Wrapping UpHalogen组件使用Action类型来处理组件内部出现的各种事件。我们现在已经看到了这种情况可能发生的所有常见方式: 用户与我们呈现的HTML元素的交互 生命周期事件 订阅，无论是通过Aff和Effect函数还是来自DOM上的事件侦听器您现在已经了解了单独使用Halogen组件的所有基本知识。在下一章中，我们将学习如何将Halogen组件组合成父组件和子组件的树。" }, { "title": "Halogen-04-执行Effects", "url": "/posts/Halogen-04-%E6%89%A7%E8%A1%8CEffects/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "Performing Effects到目前为止，我们已经涵盖了很多领域。您知道如何编写Halogen HTML。您可以定义响应用户交互的组件并按类型对组件的每个部分进行建模, 有了这个基础，我们就可以在编写应用程序时继续使用另一个重要的工具: 执行effects。在本章中，我们将通过两个示例探索如何在您的组件中执行effects: 生成随机数并发出HTTP请求。一旦您知道如何执行effects，您就可以很好地掌握Halogen基础知识.在我们开始之前，重要的是要知道您只能在评估期间执行effects，例如像handleAction这样使用HalogenM类型的函数. 但是您无法在生成初始状态或渲染期间执行effects。由于您只能在HalogenM中执行effects，因此在深入研究示例之前，让我们简要了解一下它的更多信息。HalogenM类型如果您还记得上一章的内容，handleAction函数会返回一个名为HalogenM的类型。这是我们写的handleAction:handleAction :: forall output m. Action -&amp;gt; HalogenM State Action () output m UnitHalogenM是Halogen的关键部分，通常称为eval单子。这个monad启用了Halogen特性，如状态、分叉线程、开始订阅等。但它非常有限，仅与Halogen特定的性质有关。事实上，Halogen组件没有内置的effects机制！相反，Halogen允许您选择要在组件中与HalogenM一起使用的monad。您可以访问HalogenM的所有功能以及您选择的monad支持的任何功能. 这用类型参数m表示，它代表monad。仅使用Halogen特定性质的组件可以让此类型参数保持打开状态。例如，我们的计数器只更新状态。但是执行effects的组件可以使用 Effect或Aff monad，或者您可以提供自己的自定义monad。这个handleAction可以使用来自HalogenM的函数，比如modify_，也可以使用来自Effect的effectful函数:handleAction :: forall output. Action -&amp;gt; HalogenM State Action () output Effect Unit这个可以使用来自HalogenM的函数以及来自Aff的effectful函数:handleAction :: forall output. Action -&amp;gt; HalogenM State Action () output Aff Unit在Halogen中更常见的是对类型参数m使用约束来描述monad可以做什么，而不是选择特定的monad, 这允许您随着应用程序的增长将多个monad混合在一起。例如，大多数Halogen应用程序将通过以下类型签名使用来自Aff的函数:handleAction :: forall output m. MonadAff m =&amp;gt; Action -&amp;gt; HalogenM State Action () output m Unit这让您可以完成硬编码Aff类型所做的一切，但也可以让您混合其他约束。最后一件事: 当你为你的组件选择一个monad时，它会出现在你的HalogenM类型、你的Component类型中，如果你正在使用子组件，那么它会出现在你的ComponentHTML类型中:component :: forall query input output m. MonadAff m =&amp;gt; H.Component query input output mhandleAction :: forall output m. MonadAff m =&amp;gt; Action -&amp;gt; HalogenM State Action () output m Unit-- We aren&#39;t using child components, so we don&#39;t have to use the constraint here, but-- we&#39;ll learn about when it&#39;s required in the parent &amp;amp; child components chapter.render :: forall m. State -&amp;gt; H.ComponentHTML Action () m一个Effect例子: 随机数让我们创建一个新的简单组件，每次单击按钮时都会生成一个新的随机数。在您阅读示例时，请注意它如何使用与我们用于编写计数器的相同类型和函数。随着时间的推移，您将习惯于快读Halogen组件的状态、动作和其他类型，以了解其功能的要点，并熟悉标准函数，如initialState、render 和 handleAction。 您可以将此示例粘贴到Try Purescript中以交互方式探索它。您还可以在此存储库的示例目录中查看并运行完整的示例代码。请注意，我们没有在我们的initialState或render函数中执行任何effects – 例如，我们将我们的状态初始化为Nothing而不是为我们的初始状态生成一个随机数 —— 但是我们可以在我们的handleAction函数(使用HalogenM类型)中自由地执行effects。module Main whereimport Preludeimport Data.Maybe (Maybe(..), maybe)import Effect (Effect)import Effect.Class (class MonadEffect)import Effect.Random (random)import Halogen as Himport Halogen.Aff (awaitBody, runHalogenAff)import Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = runHalogenAff do body &amp;lt;- awaitBody runUI component unit bodytype State = Maybe Numberdata Action = Regeneratecomponent :: forall query input output m. MonadEffect m =&amp;gt; H.Component query input output mcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } }initialState :: forall input. input -&amp;gt; StateinitialState _ = Nothingrender :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender state = do let value = maybe &quot;No number generated yet&quot; show state HH.div_ [ HH.h1_ [ HH.text &quot;Random number&quot; ] , HH.p_ [ HH.text (&quot;Current value: &quot; &amp;lt;&amp;gt; value) ] , HH.button [ HE.onClick \\_ -&amp;gt; Regenerate ] [ HH.text &quot;Generate new number&quot; ] ]handleAction :: forall output m. MonadEffect m =&amp;gt; Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Regenerate -&amp;gt; do newNumber &amp;lt;- H.liftEffect random H.modify_ \\_ -&amp;gt; Just newNumber如您所见，执行effects的组件与不执行effects的组件没有太大区别！我们只做了两件事: 我们为组件和handleAction函数的m类型参数添加了MonadEffect约束. 我们的render函数不需要约束，因为我们没有任何子组件。 我们实际上第一次使用了一个effect: random函数，它来自Effect.Random。让我们再分解一下这个effect。-- [1]handleAction :: forall output m. MonadEffect m =&amp;gt; Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Regenerate -&amp;gt; do newNumber &amp;lt;- H.liftEffect random -- [2] H.modify_ \\_ -&amp;gt; Just newNumber -- [3] 我们已经限制了我们的m类型参数说我们支持任何monad，只要那个monad支持MonadEffect. 这是”我们需要能够在我们的评估代码中使用Effect函数”的另一种说法。 随机函数的类型为Effect Number。但是我们不能直接使用它：我们的组件不支持Effect而是支持任何monad m，只要该monad可以从Effect运行effects. 这是一个细微的区别，但最终我们要求random函数的类型为MonadEffect m =&amp;gt; m Number而不是直接为 Effect. 幸运的是，我们可以使用LiftEffect函数将任何Effect类型转换为MonadEffect m =&amp;gt; m。这是Halogen中的常见模式，因此如果您使用MonadEffect，请记住liftEffect。 modify_函数让你更新状态，它直接来自带有其他状态更新功能的HalogenM。在这里，我们使用它来将新的随机数写入我们的状态。这是一个很好的示例，说明您可以如何自由地将Effect中的effects与特定于Halogen的函数(如modify_)交织在一起。让我们再做一次，这次使用Aff monad来实现异步效果。一个Aff例子: HTTP Requests从Internet上的其他地方获取信息是很常见的。例如，假设我们想使用GitHub的API来获取用户。我们将使用affjax包来发出我们的请求, 它本身依赖于Aff monad来实现异步效果。不过，这个例子更有趣: 我们还将使用preventDefault函数来防止表单提交刷新页面，该页面在Effect中运行。这意味着我们的示例展示了如何将不同的effects(Effect和Aff)与Halogen函数(HalogenM)交织在一起。 与Random示例一样，您可以将此示例粘贴到Try Purescript中以交互方式探索它。您还可以在此存储库的examples目录中查看并运行完整的示例代码.这个组件定义应该看起来很熟悉。我们定义我们的State和Action类型并实现我们的initialState、render和handleAction函数. 我们将它们组合到我们的组件规范中，并将它们变成一个有效的组件H.mkComponent。再次注意，我们的effects集中在handleAction函数中，并且在构造初始状态或渲染Halogen HTML时没有执行任何effects。module Main whereimport Preludeimport Affjax as AXimport Affjax.ResponseFormat as AXRFimport Data.Either (hush)import Data.Maybe (Maybe(..))import Effect (Effect)import Effect.Aff.Class (class MonadAff)import Halogen as Himport Halogen.Aff (awaitBody, runHalogenAff)import Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.HTML.Properties as HPimport Halogen.VDom.Driver (runUI)import Web.Event.Event (Event)import Web.Event.Event as Eventmain :: Effect Unitmain = runHalogenAff do body &amp;lt;- awaitBody runUI component unit bodytype State = { loading :: Boolean , username :: String , result :: Maybe String }data Action = SetUsername String | MakeRequest Eventcomponent :: forall query input output m. MonadAff m =&amp;gt; H.Component query input output mcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } }initialState :: forall input. input -&amp;gt; StateinitialState _ = { loading: false, username: &quot;&quot;, result: Nothing }render :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender st = HH.form [ HE.onSubmit \\ev -&amp;gt; MakeRequest ev ] [ HH.h1_ [ HH.text &quot;Look up GitHub user&quot; ] , HH.label_ [ HH.div_ [ HH.text &quot;Enter username:&quot; ] , HH.input [ HP.value st.username , HE.onValueInput \\str -&amp;gt; SetUsername str ] ] , HH.button [ HP.disabled st.loading , HP.type_ HP.ButtonSubmit ] [ HH.text &quot;Fetch info&quot; ] , HH.p_ [ HH.text $ if st.loading then &quot;Working...&quot; else &quot;&quot; ] , HH.div_ case st.result of Nothing -&amp;gt; [] Just res -&amp;gt; [ HH.h2_ [ HH.text &quot;Response:&quot; ] , HH.pre_ [ HH.code_ [ HH.text res ] ] ] ]handleAction :: forall output m. MonadAff m =&amp;gt; Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of SetUsername username -&amp;gt; do H.modify_ _ { username = username, result = Nothing } MakeRequest event -&amp;gt; do H.liftEffect $ Event.preventDefault event username &amp;lt;- H.gets _.username H.modify_ _ { loading = true } response &amp;lt;- H.liftAff $ AX.get AXRF.string (&quot;https://api.github.com/users/&quot; &amp;lt;&amp;gt; username) H.modify_ _ { loading = false, result = map _.body (hush response) }这个例子特别有趣，因为: 它混合了来自多个monad的函数(preventDefault是Effect，AX.get是Aff，gets和modify_是HalogenM)。我们可以使用liftEffect和liftAff以及我们的约束来确保一切都很好地协同工作。 我们只有一个约束，MonadAff。那是因为任何可以在Effect中运行的东西也可以在Aff中运行，所以MonadAff意味着 MonadEffect。 我们正在一次评估中进行多个状态更新。最后一点特别重要：当您修改组件呈现的状态时。这意味着在本次评估期间，我们: 将loading设置为true,这会导致组件重新渲染并显示Working.. 将loading设置为false并更新结果，这会导致组件重新渲染并显示结果(如果有的话)。值得注意的是，因为我们使用的是MonadAff，所以我们的请求不会阻止组件做其他工作，而且我们不必处理回调来获得这种异步超能力。我们在MakeRequest中编写的计算只是暂停，直到我们得到响应，然后继续第二次更新状态。仅在必要时修改状态并在可能的情况下一起批量更新是一个聪明的主意(就像我们调用modify_一次来更新loading和result字段一样). 这有助于确保您只在需要时重新渲染。重新审视事件处理在这个例子中发生了很多事情，所以值得花点时间关注它引入的新事件处理特性。与按钮示例的简单点击处理程序不同, 此处定义的处理程序确实使用了它们所提供的事件数据: 用户名输入的值由onValueInput处理程序(SetUsername操作)使用。 在onSubmit处理程序(MakeRequest操作)中的事件上调用preventDefault。传递给处理程序的参数类型取决于用于附加它的函数。有时，对于onValueInput，处理程序只是接收从事件中提取的数据 - 在这种情况下是字符串。大多数其他on...函数设置一个处理程序来接收整个事件，或者作为Event类型的值，或者作为像MouseEvent这样的特殊类型。详细信息可以在Halogen.HTML.Events的模块文档中找到；用于事件的类型和函数可以在web-events和web-uievents包中找到。" }, { "title": "Halogen-03-组件", "url": "/posts/Halogen-03-%E7%BB%84%E4%BB%B6/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "组件介绍Halogen HTML是Halogen应用程序的基本构建块之一。但是，生成HTML的纯函数缺少实际应用程序所需的许多基本功能: 表示随时间变化的值的状态、对网络请求等事物的effects以及响应DOM事件的能力(例如，当用户单击按钮时).Halogen组件接受input并生成Halogen HTML, 就像我们目前看到的函数一样。然而, 与函数不同的是，组件维护内部状态，可以更新其状态或执行响应事件的effects，并且可以与其他组件通信。Halogen使用组件架构。这意味着Halogen使用组件让您将UI拆分为独立的、可重复使用的部件并单独考虑每个部件。然后，您可以将组件组合在一起以生成复杂的应用程序.例如，每个Halogen应用程序都由至少一个组件组成，称为root组件。Halogen组件可以包含更多组件，生成的组件树构成您的Halogen应用程序。在本章中，我们将学习编写Halogen组件的大部分基本类型和函数。对于初学者来说，这是本指南中最难的一章，因为其中许多概念都是全新的。如果您第一次阅读它感到不知所措，请不要担心！当您编写Halogen应用程序时，您将一遍又一遍地使用这些类型和函数，它们很快就会成为第二天性。如果您在阅读本章时遇到困难，请尝试在构建一个不同于此处描述的简单组件的同时再次阅读它。在本章中，我们还将看到更多Halogen声明式编程风格的示例。当你编写一个组件时，你负责描述对于任何给定的内部状态应该存在什么样的UI。Halogen在幕后更新实际的DOM元素以匹配您想要的UI。一个小例子我们已经看到了一个简单的组件示例：一个可以递增或递减的计数器。module Main whereimport Preludeimport Halogen as Himport Halogen.HTML as HHimport Halogen.HTML.Events as HEdata Action = Increment | Decrementcomponent = H.mkComponent { initialState , render , eval: H.mkEval H.defaultEval { handleAction = handleAction } } where initialState _ = 0 render state = HH.div_ [ HH.button [ HE.onClick \\_ -&amp;gt; Decrement ] [ HH.text &quot;-&quot; ] , HH.text (show state) , HH.button [ HE.onClick \\_ -&amp;gt; Increment ] [ HH.text &quot;+&quot; ] ] handleAction = case _ of Decrement -&amp;gt; H.modify_ \\state -&amp;gt; state - 1 Increment -&amp;gt; H.modify_ \\state -&amp;gt; state + 1该组件维护一个整数作为其内部状态，并更新该状态以响应两个按钮上的点击事件。这个组件可以工作，但在现实世界的应用程序中，我们不会不指定所有类型。让我们用它使用的所有类型从头开始重建这个组件。构建基本组件(带类型)典型的Halogen组件接受input，维持内部状态, 从该状态生成Halogen HTML, 并根据事件更新其状态或执行effects, 在这个实例中，我们不需要执行任何effects，但我们很快就会介绍它们。让我们分解组件的每个部分，并在此过程中分配类型。处理输入Halogen组件可以接受来自父组件或应用程序根的input。如果您将组件视为一个函数，那么input就是该函数的参数。如果你的组件接受input，那么你应该用类型来描述它。例如，接受整数作为input的组件将使用以下类型:type Input = Int我们的计数器不需要任何input，所以我们有两个选择。首先，我们可以说我们的输入类型是Unit，这意味着我们只需要一个虚拟值并将其丢弃：type Input = Unit其次，更常见的是，我们的input类型出现在组件中的任何地方，我们都可以简单地将其保留为类型变量forall i. ..., 使用任何一种方法都很好，但从这里开始，我们将使用类型变量来表示我们的组件不使用的类型。状态Halogen组件会随着时间的推移保持内部状态，用于驱动组件的行为并生成HTML。我们的counter组件维护当前计数，一个整数，所以我们将使用它作为我们的状态类型:type State = Int我们的组件还需要产生一个初始状态值。所有Halogen组件都需要一个initialState函数，该函数从input值生成初始状态:initialState :: Input -&amp;gt; State我们的counter组件不使用它的input，所以我们的initialState函数不会使用input类型，而只会让该类型变量保持打开状态。当组件运行时，我们的计数器应该从0开始。initialState :: forall input. input -&amp;gt; StateinitialState _ = 0处理动作Halogen组件可以更新状态、执行effects并与其他组件通信以响应内部出现的事件, 组件使用action类型来描述组件可以做哪些事情来响应内部事件。我们的计数器有两个内部事件: -按钮上的单击事件以减少计数 +按钮上的单击事件以增加计数我们可以使用我们称为Action的数据类型来描述我们的组件应该做什么来响应这些事件:data Action = Increment | Decrement这种类型表示我们的组件能够递增和递减。稍后，我们将看到在我们的HTML中使用这种类型——Halogen声明特性的另一个例子。就像我们的state类型必须与一个描述如何生成State值的initialState函数配对一样，我们的Action类型应该与一个名为handleAction的函数配对，该函数描述当这些actions之一发生时要做什么。handleAction :: forall output m. Action -&amp;gt; H.HalogenM State Action () output m Unit与我们的input类型一样，我们可以为我们不使用的类型保留类型变量。 类型()表示我们的组件没有子组件。我们也可以将它作为类型变量打开，因为我们没有使用它 —— slots，按照惯例 —— 但是()太短了，您会看到这种类型被普遍使用。 output类型参数仅在您的组件与父组件通信时使用。 m类型参数仅在您的组件执行effects时相关。由于我们的计数器没有子组件，我们将使用()来描述它们，并且因为它不与父组件通信或执行effects，我们将保持output和m类型变量打开。这是我们计数器的handleAction函数:handleAction :: forall output m. Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Decrement -&amp;gt; H.modify_ \\state -&amp;gt; state - 1 Increment -&amp;gt; H.modify_ \\state -&amp;gt; state + 1我们的handleAction函数通过将我们的状态变量减少1来响应Decrement，并通过将我们的状态变量增加1来响应 Increment。 modify允许您更新状态，给定先前的状态，返回新状态 modify_与modify相同，但它不返回新状态(因此您不必像使用modify那样显式丢弃结果) get允许您检索当前状态 gets允许您检索当前状态并对其应用函数(最常见的是_.fieldName从记录中检索特定字段)当我们谈论执行effects时，我们会更多地谈论HalogenM。我们的计数器不执行effects，所以我们需要的只是状态更新函数。渲染函数Halogen组件使用称为render的函数从它们的状态生成HTML。每次状态改变时渲染函数都会运行。这就是Halogen声明性的原因: 对于任何给定的状态，您描述它对应的UI。Halogen处理确保状态更改始终导致您描述的UI的工作量。Halogen中的渲染函数是纯的，这意味着您无法在渲染过程中执行诸如获取当前时间、发出网络请求或其他类似操作。您所能做的就是为您的状态值生成HTML。当我们查看渲染函数的类型时，我们可以看到我们在上一章中提到的ComponentHTML类型。此类型是HTML类型的更专业版本, 专门用于组件中生成的HTML。再次, 我们将使用()并让m保持打开状态，因为它们仅在使用子组件时相关，我们将在后面的章节中介绍。render :: forall m. State -&amp;gt; H.ComponentHTML Action () m现在我们正在使用我们的渲染函数，我们回到上一章应该熟悉的Halogen HTML！你可以像上一章一样在ComponentHTML中编写常规HTML:import Halogen.HTML.Eventsrender :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender state = HH.div_ [ HH.button [ HE.onClick \\_ -&amp;gt; Decrement ] [ HH.text &quot;-&quot; ] , HH.text (show state) , HH.button [ HE.onClick \\_ -&amp;gt; Increment ] [ HH.text &quot;+&quot; ] ]处理事件我们现在可以看到如何在Halogen中处理事件。首先，您在属性数组中编写事件处理程序以及您可能需要的任何其他properties、attributes和引用，然后，您将事件处理程序与组件知道如何处理的Action相关联。最后，当事件发生时，你的handleAction函数被调用来处理事件。您可能很好奇我们为什么要向onClick提供匿名函数。要了解原因，我们可以查看onClick的实际类型:onClick :: forall row action . (MouseEvent -&amp;gt; action) -&amp;gt; IProp (onClick :: MouseEvent | row) action-- Specialized to our componentonClick :: forall row . (MouseEvent -&amp;gt; Action) -&amp;gt; IProp (onClick :: MouseEvent | row) Action在Halogen中，事件处理程序将回调作为它们的第一个参数。此回调接收发生的DOM事件(在单击事件的情况下，这是一个 MouseEvent), 它包含一些您可能想要使用的元数据，然后负责返回Halogen应运行以响应事件的action。在我们的例子中，我们不会检查事件本身，所以我们扔掉参数并返回我们想要运行的action(Increment或Decrement)。然后onClick函数返回IProp类型的值。你应该记得上一章的IProp。作为复习，Halogen HTML元素指定了它们支持的属性和事件的列表。属性和事件依次指定它们的类型。Halogen然后能够确保您永远不会在不支持它的元素上使用属性或事件。在这种情况下，按钮确实支持onClick事件，所以我们很高兴！在这个简单的例子中，MouseEvent参数被传递给onClick的处理函数忽略，因为action完全由哪个按钮接收click来决定。在查看本指南第3部分中的effects后，我们将讨论访问事件本身。把这一切结合在一起让我们将每个类型和函数重新组合起来以生成我们的计数器组件——这次是指定类型。让我们重新审视我们编写的类型和函数:-- This can be specified if your component takes input, or you can leave-- the type variable open if your component doesn&#39;t.type Input = Unittype State = IntinitialState :: forall input. input -&amp;gt; StateinitialState = ...data Action = Increment | DecrementhandleAction :: forall output m. Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = ...render :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender = ...这些类型和函数是典型Halogen组件的核心构建块。但是像这样仅靠它们是不够的 —— 我们需要将它们集中到一个地方。我们将使用H.mkComponent函数来做到这一点。该函数接受一个ComponentSpec，它是一个包含initialState、render和eval函数的记录，并从中生成一个Component:component = H.mkComponent { -- First, we provide our function that describes how to produce the first state initialState -- Then, we provide our function that describes how to produce HTML from the state , render -- Finally, we provide our function that describes how to handle actions that -- occur while the component is running, which updates the state. , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } }我们将在以后的章节中更多地讨论eval函数。暂时您可以将eval函数视为定义组件如何响应事件; 目前，我们唯一关心的事件类型是actions，因此我们将使用的唯一函数是handleAction。我们的组件现在已经完成，但我们缺少最后一个类型定义：我们的组件类型。H.Component类型mkComponent函数从一个ComponentSpec生成一个组件，它是Halogen运行一个组件所需的函数的记录。我们将在后续章节中更详细地介绍这种类型。mkComponent :: H.ComponentSpec ... -&amp;gt; H.Component query input output m生成的组件的类型为H.Component,它本身采用四个类型参数来描述组件的公共接口, 我们的组件不与父组件或子组件通信，因此它不使用任何这些类型变量。不过，我们现在将简要介绍它们，以便您了解后续章节中的内容。 第一个参数query表示父组件可以与此组件通信的方式。说到父组件和子组件时，我们会更多地讨论它。 第二个参数input代表我们的组件接受的input。在我们的例子中，组件不接受任何输入，所以我们将保持这个变量打开。 第三个参数output表示该组件与其父组件进行通信的一种方式。当我们谈论父组件和子组件时，我们会更多地谈论它。 最后一个参数m表示可用于在组件中运行effects的monad。我们的组件不运行任何effects，所以我们将这个变量保持打开状态。因此，我们可以通过将所有H.Component类型变量保持打开状态来指定我们的计数器组件。最终产品这是很多东西！我们终于用类型完全指定了我们的计数器组件。如果您可以轻松地构建这样的组件，您基本上是全面了解构建 Halogen组件的大部分方法。本指南的其余部分将建立在您对state、action和rendering HTML的理解之上。我们添加了一个主函数来运行我们的Halogen应用程序，以便您可以通过将其粘贴到Try PureScript中来试用此示例, 我们将在后面的章节中介绍如何运行Halogen应用程序 —— 现在您可以忽略main函数并专注于我们定义的组件。module Main whereimport Preludeimport Effect (Effect)import Halogen as Himport Halogen.Aff as HAimport Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit bodytype State = Intdata Action = Increment | Decrementcomponent :: forall query input output m. H.Component query input output mcomponent = H.mkComponent { initialState , render , eval: H.mkEval H.defaultEval { handleAction = handleAction } }initialState :: forall input. input -&amp;gt; StateinitialState _ = 0render :: forall m. State -&amp;gt; H.ComponentHTML Action () mrender state = HH.div_ [ HH.button [ HE.onClick \\_ -&amp;gt; Decrement ] [ HH.text &quot;-&quot; ] , HH.text (show state) , HH.button [ HE.onClick \\_ -&amp;gt; Increment ] [ HH.text &quot;+&quot; ] ]handleAction :: forall output m. Action -&amp;gt; H.HalogenM State Action () output m UnithandleAction = case _ of Decrement -&amp;gt; H.modify_ \\state -&amp;gt; state - 1 Increment -&amp;gt; H.modify_ \\state -&amp;gt; state + 1" }, { "title": "Halogen-02-渲染HalogenHTML", "url": "/posts/Halogen-02-%E6%B8%B2%E6%9F%93HalogenHTML/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "渲染Halogen HTMLHalogen HTML元素是Halogen应用程序的最小构建块。这些元素描述了您希望在屏幕上看到的内容。Halogen HTML元素不是组件（我们将在下一章中介绍组件），如果没有组件，元素就无法呈现。但是，编写生成Halogen HTML的辅助函数然后在组件中使用这些函数是很常见的。在本章中，我们将探索在没有组件或事件的情况下编写HTML。Halogen HTML您可以使用Halogen.HTML或Halogen.HTML.Keyed模块中的函数编写Halogen HTML，如下例所示：import Halogen.HTML as HHelement = HH.h1 [ ] [ HH.text &quot;Hello, world&quot; ]Halogen HTML元素可以被认为是浏览器DOM元素, 但它们由Halogen库控制，而不是DOM中的实际元素。在幕后，Halogen负责更新实际DOM以匹配您编写的代码。Halogen中的元素接受两个参数： 应用于元素的attributes、properties、event handlers和/或references的数组.这些对应于普通的HTML属性(如placeholder)和事件处理程序(如onClick)。我们将在下一章学习如何处理事件，本章只关注属性。 子元素数组，如果该元素支持子元素。举个简单的例子，让我们把这个普通的HTML翻译成Halogen HTML：&amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;input placeholder=&quot;Name&quot; /&amp;gt; &amp;lt;button class=&quot;btn-primary&quot; type=&quot;submit&quot;&amp;gt; Submit &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;让我们分解我们的Halogen HTML： 我们的Halogen代码具有与普通HTML相同的形状：一个div包含一个input和一个button，button本身包含纯文本。 属性从标签内的键值对移动到元素的属性数组中. 如果元素支持子元素，则子元素从标签内移动到子元素数组。import Halogen.HTML as HHimport Halogen.HTML.Properties as HPhtml = HH.div [ HP.id &quot;root&quot; ] [ HH.input [ HP.placeholder &quot;Name&quot; ] , HH.button [ HP.classes [ HH.ClassName &quot;btn-primary&quot; ] , HP.type_ HP.ButtonSubmit ] [ HH.text &quot;Submit&quot; ] ]您可以在此处看到Halogen对类型安全的重视: text input不能有子元素，因此Halogen不允许该元素将更多元素作为参数。 button的type属性只能使用某些值，因此Halogen使用sum类型来限制它们。 CSS classes使用ClassName newtype，以便在需要时可以对其进行特殊处理；例如，classes函数确保您的classes在组合时以空格分隔。一些HTML元素和属性与PureScript中的保留关键字或Prelude中的常见函数发生冲突，因此Halogen为它们添加了下划线。这就是为什么您在上面的示例中看到type_而不是type的原因。当您不需要在Halogen HTML元素上设置任何属性时，您可以改用其带下划线的版本。例如，下面的div和button元素没有属性：html = HH.div [ ] [ HH.button [ ] [ HH.text &quot;Click me!&quot;] ]这意味着我们可以使用它们的下划线版本重写它们。这有助于保持HTML整洁:html = HH.div_ [ HH.button_ [ HH.text &quot;Click me!&quot; ] ]在 Halogen HTML 中编写函数为Halogen HTML编写辅助函数是很常见的。由于Halogen HTML是由普通的PureScript函数构建的，因此您可以在代码中自由穿插其他函数。在这个例子中，我们的函数接受一个整数并将其呈现为文本:header :: forall w i. Int -&amp;gt; HH.HTML w iheader visits = HH.h1_ [ HH.text $ &quot;You&#39;ve had &quot; &amp;lt;&amp;gt; show visits &amp;lt;&amp;gt; &quot; visitors&quot; ] 我们还可以渲染事物列表:lakes = [ &quot;Lake Norman&quot;, &quot;Lake Wylie&quot; ]html :: forall w i. HH.HTML w ihtml = HH.div_ (map HH.text lakes)-- same as: HH.div_ [ HH.text &quot;Lake Norman&quot;, HH.text &quot;Lake Wylie&quot; ]这些函数引入了一种新类型HH.HTML，这是您以前从未见过的。别担心！这是Halogen HTML的类型，我们将在下一节中了解它。现在，让我们继续学习在HTML中使用函数。一个常见的要求是有条件地呈现一些HTML. 你可以用普通的if和case语句来做到这一点，但为常见模式编写辅助函数很有用. 让我们来看看您可能在自己的应用程序中编写的两个辅助函数，这将帮助我们获得更多使用Halogen HTML编写函数的练习。首先，您有时可能需要处理可能存在或不存在的元素。像下面这样的函数可以让你渲染一个存在的值，否则渲染一个空节点。maybeElem :: forall w i a. Maybe a -&amp;gt; (a -&amp;gt; HH.HTML w i) -&amp;gt; HH.HTML w imaybeElem val f = case val of Just x -&amp;gt; f x _ -&amp;gt; HH.text &quot;&quot;-- 如果name有的话, 则渲染它renderName :: forall w i. Maybe String -&amp;gt; HH.HTML w irenderName mbName = maybeElem mbName \\name -&amp;gt; HH.text name其次，您可能只想在条件为真时呈现一些HTML，如果条件不符合，则不计算HTML。您可以通过将其评估隐藏在函数后面来实现此目的，这样HTML仅在条件为真时才计算。whenElem :: forall w i. Boolean -&amp;gt; (Unit -&amp;gt; HH.HTML w i) -&amp;gt; HH.HTML w iwhenElem cond f = if cond then f unit else HH.text &quot;&quot;-- 渲染旧的number，但前提是它与新的number不同renderOld :: forall w i. { old :: Number, new :: Number } -&amp;gt; HH.HTML w irenderOld { old, new } = whenElem (old /= new) \\_ -&amp;gt; HH.div_ [ HH.text $ show old ]现在我们已经探索了几种使用HTML的方法，让我们了解更多关于描述它的类型。HTML 类型到目前为止，我们已经编写了没有类型签名的HTML。但是当您在应用程序中编写Halogen HTML时，您将包含类型签名。HTML w iHTML是Halogen中HTML的核心类型,它用于不绑定到特定类型组件的HTML元素. 例如，它被用作我们目前看到的h1、text和button元素的类型。您也可以在定义自己的自定义HTML元素时使用此类型。HTML类型有两个类型参数：w，代表widget，描述可以在HTML中使用哪些组件；i，代表input，代表用于处理 DOM事件的类型。当您为Halogen HTML编写不需要响应DOM事件的辅助函数时, 那么您通常会使用HTML类型而不指定w和i是什么。例如，这个辅助函数可以让你创建一个按钮，给定一个标签:primaryButton :: forall w i. String -&amp;gt; HH.HTML w iprimaryButton label = HH.button [ HP.classes [ HH.ClassName &quot;primary&quot; ] ] [ HH.text label ]你也可以接受HTML作为标签，而不是只接受一个字符串:primaryButton :: forall w i. HH.HTML w i -&amp;gt; HH.HTML w iprimaryButton label = HH.button [ HP.classes [ HH.ClassName &quot;primary&quot; ] ] [ label ]当然，作为一个按钮，您可能希望在单击它时执行某些操作。别担心——我们将在下一章介绍处理DOM事件！ComponentHTML 和 PlainHTML您通常会在Halogen应用程序中看到另外两种HTML类型.当您编写旨在处理特定类型组件的HTML时，将使用ComponentHTML。它也可以在组件外部使用，但最常用于组件内部。我们将在下一章中了解有关此类型的更多信息。PlainHTML是限制性更强的HTML版本，用于不包含组件且不响应DOM中的事件的HTML.该类型允许您隐藏HTML的两个类型参数，这在您将HTML作为值传递时非常方便。但是，如果要将这种类型的值与其他响应DOM事件或包含组件的HTML组合时，则需要使用fromPlainHTML进行转换.IProp当您从Halogen.HTML.Properties和Halogen.HTML.Events模块中查找函数时,您会看到IProp类型突出显示。例如，这是一个placeholder函数，它可以让您在文本字段上设置字符串placeholder属性:placeholder :: forall r i. String -&amp;gt; IProp (placeholder :: String | r) iplaceholder = prop (PropName &quot;placeholder&quot;)IProp类型用于事件和属性,它使用row类型来唯一标识特定事件和属性；当您将这些属性之一与Halogen HTML元素结合使用时, Halogen能够验证您应用该属性的元素是否实际支持它。这是可能的，因为Halogen HTML元素还带有一个row类型，其中列出了它可以支持的所有属性和事件. 当您将属性或事件应用于元素时，Halogen会在HTML元素的row类型中查找它是否支持该属性或事件。这有助于确保您的HTML格式良好。例如, 根据DOM规范，&amp;lt;div&amp;gt;元素不支持placeholder属性, 因此，如果您尝试在 Halogen中为div提供placeholder属性，则会出现编译时错误:-- ERROR: Could not match type ( placeholder :: String | r )-- with type ( accessKey :: String, class :: String, ... )html = HH.div [ HP.placeholder &quot;blah&quot; ] [ ]此错误告诉您，您尝试将属性与不支持它的元素一起使用。它首先列出您尝试使用的属性，然后列出元素支持的属性。Halogen类型安全的另一个例子！添加缺失的属性HTML是一种不断被修订的living standard, Halogen试图跟上这些变化，但有时会落后.(如果您对我们如何自动化检测这些变化的过程有任何想法，请告诉我们)您可能会发现Halogen中缺少某些属性。例如，您可以尝试编写:html = HH.iframe [ HP.sandbox &quot;allow-scripts&quot; ]只收到此错误:Unknown value HP.sandbox即使看起来应该支持此属性:type HTMLiframe = Noninteractive ( height :: CSSPixel, name :: String, onLoad :: Event, sandbox :: String, src :: String, srcDoc :: String, width :: CSSPixel)解决方案是编写您自己的此缺失属性的实现:sandbox :: forall r i. String -&amp;gt; HH.IProp ( sandbox :: String | r ) isandbox = HH.prop (HH.PropName &quot;sandbox&quot;)然后你可以在你的HTML元素中使用它:html = HH.iframe [ sandbox &quot;allow-scripts&quot; ]请打开一个问题或PR以添加此缺少的属性。这是一种为Halogen做出贡献的简单方法。" }, { "title": "Halogen-01-指南", "url": "/posts/Halogen-01-%E6%8C%87%E5%8D%97/", "categories": "前端 purescript halogen", "tags": "前端 purescript halogen", "date": "2022-01-02 11:04:00 +0800", "snippet": "Halogen指南Halogen是一个声明式的、基于组件的用于PureScript的UI库，它强调类型安全。在本指南中，您将学习在Halogen中编写实际应用程序所需的核心思想和模式。这是一个微型Halogen应用程序，可让您递增和递减计数器:module Main whereimport Preludeimport Effect (Effect)import Halogen as Himport Halogen.Aff as HAimport Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.VDom.Driver (runUI)main :: Effect Unitmain = HA.runHalogenAff do body &amp;lt;- HA.awaitBody runUI component unit bodydata Action = Increment | Decrementcomponent = H.mkComponent { initialState , render , eval: H.mkEval $ H.defaultEval { handleAction = handleAction } } where initialState _ = 0 render state = HH.div_ [ HH.button [ HE.onClick \\_ -&amp;gt; Decrement ] [ HH.text &quot;-&quot; ] , HH.div_ [ HH.text $ show state ] , HH.button [ HE.onClick \\_ -&amp;gt; Increment ] [ HH.text &quot;+&quot; ] ] handleAction = case _ of Increment -&amp;gt; H.modify_ \\state -&amp;gt; state + 1 Decrement -&amp;gt; H.modify_ \\state -&amp;gt; state - 1你可以粘贴这个例子(以及本指南中的任何其他完整示例)到Try PureScript。我们强烈建议您这样做以交互方式探索示例！例如，尝试更改按钮，使它们使用Increment和Decrement而不是符号+和-。 默认情况下，每次进行更改时,Try PureScript都会编译。您还可以禁用自动编译功能，这将导致 Try PureScript 等待您单击Compile按钮来编译您的Halogen应用程序.您还可以使用官方Halogen模板创建自己的入门项目。此模板包含额外的工具和脚本，可帮助您启动并运行完整的Halogen应用程序.不要担心这些代码一开始是否会让人不知所措——当您阅读本指南的接下来几章时，您将对这个组件的工作原理以及如何编写自己的组件有一个深入的了解。如何阅读本指南在本指南中，我们将探索Halogen应用程序的构建块：elements(元素)和components(组件)。当您了解这些后，您就可以从可重用的小片段创建复杂的应用程序。这是对Halogen主要概念的逐步介绍。每章都建立在前几章介绍的知识的基础上，因此我们建议您按顺序通读指南。Halogen是一个PureScript库，它假定您了解PureScript概念的基本知识，例如函数、记录、数组、do符号、Effect和Aff。如果您了解HTML和DOM的基础知识，它也会有所帮助。如果您需要复习，我们建议： 对于PureScript：PureScript Book和Jordan Martinez的 PureScript Reference。 对于HTML：MDN对HTML和DOM events的介绍。目录 渲染Halogen HTML 组件介绍 执行Effects 生命周期和订阅 父/子组件 运行应用程序 下一步" } ]
